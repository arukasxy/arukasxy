<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.131.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="网络通信"><meta itemprop=description content><meta name=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=keywords content="网络"><meta property="og:type" content="article"><meta property="og:title" content="网络通信"><meta property="og:description" content><meta property="og:image" content="/imgs/hugo_next_avatar.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/telecommunication-ot0ya.html"><meta property="og:site_name" content="Sakura Notes"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="arukasxy"><meta property="article:published_time" content="2024-07-09 10:21:15 +0800 +0800"><meta property="article:modified_time" content="2024-08-08 13:08:51 +0800 +0800"><link type=text/css rel=stylesheet href=/3rd/font-awesome/6.6.0/css/all.min.css><link type=text/css rel=stylesheet href=/3rd/animate.css/4.1.1/animate.min.css><link type=text/css rel=stylesheet href=/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href=/css/main.min.ab1c3ae9fc9258afee98d91f39e4c6c4fe3d7d90222efbbe570558fcadfc2105.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"telecommunication-ot0ya.html","permalink":"/post/telecommunication-ot0ya.html","title":"网络通信","waline":{"js":[{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"2.15.8"},{"alias":"@waline/client","alias_name":"waline","file":"dist/comment.js","name":"comment","version":"2.15.8"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>网络通信 - Sakura Notes</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Sakura Notes</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>计算机,C++,数据库</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>17</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#select>select</a></li><li><a href=#poll>poll</a></li><li><a href=#epolliocp>epoll（IOCP）</a><ul><li><a href=#条件触发边缘触发>条件触发（+边缘触发）</a></li></ul></li></ul><ul><li><a href=#socket地址>socket地址</a></li><li><a href=#读写>读写</a></li></ul><ul><li><a href=#httprpc>HTTP（+RPC）</a><ul><li><a href=#请求报文请求方法>请求报文（+请求方法）</a></li><li><a href=#响应报文状态码>响应报文（+状态码）</a></li><li><a href=#强缓存和协商缓存>强缓存和协商缓存</a></li><li><a href=#http版本>HTTP版本</a></li><li><a href=#cookie与session>Cookie与Session</a></li></ul></li><li><a href=#cdn内容分发网络>CDN内容分发网络</a></li></ul><ul><li><a href=#udp>UDP</a><ul><li><a href=#实现可靠传输>实现可靠传输</a></li></ul></li><li><a href=#tcp>TCP</a><ul><li><a href=#报文解析>报文解析</a><ul><li><a href=#time_wait>TIME_WAIT</a></li></ul></li><li><a href=#流量控制>流量控制</a><ul><li><a href=#零窗口>零窗口</a></li><li><a href=#nagle算法>Nagle算法</a></li></ul></li><li><a href=#拥塞控制>拥塞控制</a><ul><li><a href=#慢开始>慢开始</a></li><li><a href=#拥塞避免>拥塞避免</a></li><li><a href=#超时重传>超时重传</a></li><li><a href=#快速重传快速恢复>快速重传（快速恢复）</a></li></ul></li><li><a href=#粘包>粘包</a></li></ul></li></ul><ul><li><a href=#ipv4和ipv6>IPv4和IPv6</a></li><li><a href=#nat协议>NAT协议</a></li></ul><ul><li><a href=#arp协议>ARP协议</a></li></ul><ul><li><a href=#ping>ping</a></li><li><a href=#输入url到显示页面>输入URL到显示页面</a></li><li><a href=#dns查询过程>DNS查询过程</a></li></ul><ul><li><a href=#转换>转换</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=arukasxy src=/imgs/img-lazy-loading.gif data-src=/imgs/hugo_next_avatar.png><p class=site-author-name itemprop=name>arukasxy</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>17</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>18</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/arukasxy title="Github → https://github.com/arukasxy" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2024-08-08T00:00:00+08:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=40777></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=90></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2024-07-10T23:45:33+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/telecommunication-ot0ya.html><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=name content="arukasxy"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="arukasxy"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="网络通信"><meta itemprop=description content="网络通信 TCP/IP模型(+OSI模型 + 常用协议) OSI模型 TCP/IP模型 功能 数据封装 常用协议（设备） 应用层 应用层 数据message HTT"></span><header class=post-header><h1 class=post-title itemprop="name headline">网络通信
<a href=https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name/post/telecommunication-ot0ya.md rel="noopener external nofollow noreferrer" target=_blank class="exturl post-edit-link" title=编辑><i class="fa fa-pen-nib"></i></a></h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-07-09 10:21:15 +0800 +0800" itemprop="dateCreated datePublished" datetime="2024-07-09 10:21:15 +0800 +0800">2024-07-09
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-08-08T13:08:51+08:00 itemprop=dateModified datetime=2024-08-08T13:08:51+08:00>2024-08-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E7%BD%91%E7%BB%9C itemprop=url rel=index><span itemprop=name>网络</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>7267</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>15分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/post/telecommunication-ot0ya.html><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h1 id=网络通信>网络通信
<a class=header-anchor href=#%e7%bd%91%e7%bb%9c%e9%80%9a%e4%bf%a1></a></h1><h1 id=tcpip模型osi模型--常用协议>TCP/IP模型(+OSI模型 + 常用协议)
<a class=header-anchor href=#tcpip%e6%a8%a1%e5%9e%8bosi%e6%a8%a1%e5%9e%8b--%e5%b8%b8%e7%94%a8%e5%8d%8f%e8%ae%ae></a></h1><table><thead><tr><th>OSI模型</th><th>TCP/IP模型</th><th>功能</th><th>数据封装</th><th>常用协议（设备）</th></tr></thead><tbody><tr><td>应用层</td><td>应用层<br></td><td></td><td>数据message</td><td>HTTPS、HTTP、Telenet、FTP、TFTP、DNS、SMTP、SSH</td></tr><tr><td>表示层</td><td></td><td></td><td></td><td></td></tr><tr><td>会话层</td><td></td><td></td><td></td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>决定传输方式</td><td>报文段<sup>（UDP datagram/TCP segment）</sup></td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>决定传输路径</td><td>数据包<sup>（packet/datagram）</sup>、分组<br></td><td>路由器、IP、ICMP、RIP、IGMP、OSPF、BGP</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>建立物理连接</td><td>帧frame</td><td>网桥、交换机、以太网、令牌环、PPP、PPTP、L2TP、ARP、ATMP、ARQ</td></tr><tr><td>物理层</td><td>物理层</td><td></td><td>比特流</td><td>物理线路、光纤、无线电、网线、集线器</td></tr></tbody></table><h1 id=io多路复用>IO多路复用
<a class=header-anchor href=#io%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8></a></h1><p>其他IO模型参考IO模型</p><h2 id=select>select
<a class=header-anchor href=#select></a></h2><ul><li><p>优点：兼容性好</p></li><li><p>缺点：</p><ul><li>每次调用select函数时向OS传递监视对象信息</li><li>调用select函数后对所有文件描述符进行循环</li><li>监听的文件描述符数量 &lt; FD_SIZE（1024）</li></ul></li><li><p>场景：服务器端接入者少；程序应具有兼容性</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>select</span>(<span style=color:#66d9ef>int</span> maxfd, fd_set <span style=color:#f92672>*</span>readset , fd_set <span style=color:#f92672>*</span>exceptset, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>timeval</span> <span style=color:#f92672>*</span>timeout);
</span></span><span style=display:flex><span><span style=color:#75715e># maxfd 监视描述符数量，设置为最大的文件描述符值+1
</span></span></span><span style=display:flex><span><span style=color:#75715e># readset 将所有关注“是否存在待读取数据”的文件描述符注册到fd_set型变量
</span></span></span><span style=display:flex><span><span style=color:#75715e># writeset 将所有关注“是否可传输无阻塞数据”的文件描述符注册到fd_set型变量
</span></span></span><span style=display:flex><span><span style=color:#75715e># exceptset 将所有关注“是否发生异常”的文件描述符注册到fd_set型变量
</span></span></span><span style=display:flex><span><span style=color:#75715e># timeout为以1/1000秒为单位的等待时间，传递-1表示等待到事件发生，传递0表示执行一次非阻塞式的检查
</span></span></span><span style=display:flex><span><span style=color:#75715e># 返回：发生错误为-1，超时返回0，事件返回描述符数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>timeval</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> tv_sec;  <span style=color:#75715e>// seconds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>long</span> tv_usec;  <span style=color:#75715e>// mircroseconds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/select.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/time.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1. 设置文件描述符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>fd_set reads, cpy_reads;  
</span></span><span style=display:flex><span>FD_ZERO(<span style=color:#f92672>&amp;</span>set); <span style=color:#75715e>// [0,0,0...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>FD_SET(listenfd, <span style=color:#f92672>&amp;</span>set);
</span></span><span style=display:flex><span>fd_max <span style=color:#f92672>=</span> listenfd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 设置监视范围
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>while</span>(true) <span style=color:#75715e>// 此时进入处理循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e># 将初始值复制到temps,以temps使用select(因为select将除发生变化的文件描述符对应位外,其余位初始化为0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cpy_reads <span style=color:#f92672>=</span> reads; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. 设置超时
</span></span></span><span style=display:flex><span><span style=color:#75715e># 当监视的文件描述符发生变化时/超时,select才返回。不设置超时,可将timeout设置为NULL
</span></span></span><span style=display:flex><span><span style=color:#75715e># 每次调用select前都需要设置超时(因为select会将timeval替换为超时前剩余时间)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>timeval</span> timeout;
</span></span><span style=display:flex><span>timeout.tv_sec <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>timeout.tv_usec <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 4. 调用select函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> select(fd_max<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>&amp;</span>cpy_reads, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>timeout);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 5. 查看调用结果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span>(result <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {  
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>错误处理</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span>(result <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e># 超时处理 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> { 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>fd_max<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>++</span>)  <span style=color:#75715e>// 遍历文件描述符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(FD_ISSET(i, <span style=color:#f92672>&amp;</span>cpy_reads)) {  <span style=color:#75715e>// 判断对应文件描述符i是否变化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span>(i <span style=color:#f92672>==</span> listenfd){
</span></span><span style=display:flex><span>                <span style=color:#75715e># connfd = accept接收请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                FD_SET(connfd, <span style=color:#f92672>&amp;</span>reads);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(fd_max <span style=color:#f92672>&lt;</span> connfd) fd_max <span style=color:#f92672>=</span> connfd;
</span></span><span style=display:flex><span>            }<span style=color:#66d9ef>else</span>{ <span style=color:#75715e>// 其他connfd有数据接收
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e># 数据读取和处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                str_len <span style=color:#f92672>=</span> read(i, buf, BUF_SIZE);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(str_len <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){ <span style=color:#75715e>// 接收的数据为EOF，需要断开连接
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    FD_CLR(i, <span style=color:#f92672>&amp;</span>reads); <span style=color:#75715e>// 断开连接
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    close(i);
</span></span><span style=display:flex><span>                }<span style=color:#66d9ef>else</span>{ ... }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=poll>poll
<a class=header-anchor href=#poll></a></h2><ul><li>优点：相比于select，无最大文件描述符数量限制</li><li>缺点：等同于select</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;poll.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>poll</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pollfd</span> <span style=color:#f92672>*</span>fds, nfds_t nfds, <span style=color:#66d9ef>int</span> timeout);
</span></span><span style=display:flex><span><span style=color:#75715e># timeout为以1/1000秒为单位的等待时间，传递-1表示等待到事件发生，传递0表示执行一次非阻塞式的检查
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pollfd</span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> fd;			<span style=color:#75715e>//文件描述符，如果暂时不关心任何事件，设为-1（忽略标准输入）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>short</span> events;	<span style=color:#75715e>//等待的事件，参考epoll
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>short</span> revents;	<span style=color:#75715e>//实际发生的事件，初始化为0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>typedef</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pollfd</span><span style=color:#f92672>&gt;</span> PollFdList;
</span></span><span style=display:flex><span>PollFdList pollfds_;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> numEvents <span style=color:#f92672>=</span> <span style=color:#f92672>::</span>poll(<span style=color:#f92672>&amp;*</span>pollfds_.begin(), pollfds_.size(), timeoutMs);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> pollfds_.begin(); iter <span style=color:#f92672>!=</span> pollfds_.end() <span style=color:#f92672>&amp;&amp;</span> numEvents <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>; iter<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(iter<span style=color:#f92672>-&gt;</span>revents <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>            <span style=color:#f92672>--</span>numEvents;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// iter-&gt;fd is the file descriptor，处理参考epoll
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=epolliocp>epoll（IOCP）
<a class=header-anchor href=#epolliocp></a></h2><ul><li><p>优点：</p><p>仅向OS传递一次监视对象</p><p>监视内容发生变化时只通知发生变化的事项</p></li><li><p>缺点：需要OS支持，且支持程度和方式存在差异</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>epoll_event</span>{
</span></span><span style=display:flex><span>	__uint32_t events;
</span></span><span style=display:flex><span>	epoll_data_t data;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>union</span> <span style=color:#a6e22e>epoll_data</span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> fd;
</span></span><span style=display:flex><span>	__uint32_t u32;
</span></span><span style=display:flex><span>	__uint64_t u64;
</span></span><span style=display:flex><span>}epoll_data_t;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 返回epoll文件描述符epfd; size为epoll例程的大小(仅供OS参考)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_create</span>(<span style=color:#66d9ef>int</span> size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 返回发生事件的文件描述符数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_wait</span>(<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>epoll_event</span> <span style=color:#f92672>*</span>events, <span style=color:#66d9ef>int</span> maxevents, <span style=color:#66d9ef>int</span> timeout);
</span></span><span style=display:flex><span><span style=color:#75715e># events保存发生事件的文件描述符集合
</span></span></span><span style=display:flex><span><span style=color:#75715e># maxevents 为可用保存的最大事件数
</span></span></span><span style=display:flex><span><span style=color:#75715e># timeout为以1/1000秒为单位的等待时间，传递-1表示等待到事件发生，传递0表示执行一次非阻塞式的检查
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e># 对文件描述符fd进行op操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_ctl</span>(<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>int</span> op, <span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>epoll_event</span> <span style=color:#f92672>*</span>event);
</span></span><span style=display:flex><span><span style=color:#75715e># op常量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>EPOLL_CTL_ADD <span style=color:#960050;background-color:#1e0010>将文件描述符注册到</span>epoll例程
</span></span><span style=display:flex><span>EPOLL_CTL_DEL <span style=color:#960050;background-color:#1e0010>从</span>epoll例程中删除文件描述符<span style=color:#960050;background-color:#1e0010>，</span>event传入NULL
</span></span><span style=display:flex><span>EPOLL_STL_MOD <span style=color:#960050;background-color:#1e0010>更改注册的文件描述符的关注事件发生情况</span>
</span></span><span style=display:flex><span><span style=color:#75715e># event常量（可用|同时设置）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>EPOLLIN <span style=color:#960050;background-color:#1e0010>需要读取数据的情况</span>
</span></span><span style=display:flex><span>EPOLLOUT <span style=color:#960050;background-color:#1e0010>输出缓冲为空，可以立即发送数据的情况</span>
</span></span><span style=display:flex><span>EPOLLPRI <span style=color:#960050;background-color:#1e0010>收到</span>OOB数据
</span></span><span style=display:flex><span>EPOLLRDHUP <span style=color:#960050;background-color:#1e0010>断开连接或半关闭的情况</span>
</span></span><span style=display:flex><span>EPOLLERR <span style=color:#960050;background-color:#1e0010>发生错误的情况</span>
</span></span><span style=display:flex><span>EPOLLET <span style=color:#960050;background-color:#1e0010>以边缘触发的方式得到事件通知</span>
</span></span><span style=display:flex><span>EPOLLONESHOT <span style=color:#960050;background-color:#1e0010>发生一次事件后，相应文件描述符不再收到事件通知，需要使用</span>op<span style=color:#f92672>=</span>EPOLL_STL_MOD再次设置事件
</span></span><span style=display:flex><span>EPOLLNVAL fd未打开
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/epoll.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define EPOLL_SIZE 50  </span><span style=color:#75715e>// 足够大，Linux2.6.8后忽略size参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>epoll_event</span> <span style=color:#f92672>*</span>ep_events;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>epoll_event</span> event;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> epfd, eventcnt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>epfd <span style=color:#f92672>=</span> epoll_create(EPOLL_SIZE);
</span></span><span style=display:flex><span>ep_events <span style=color:#f92672>=</span> malloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>epoll_event</span>)<span style=color:#f92672>*</span>EPOLL_SIZE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>event.events <span style=color:#f92672>=</span> EPOLLIN;
</span></span><span style=display:flex><span>event.data.fd <span style=color:#f92672>=</span> listenfd; <span style=color:#75715e>//listen(sockfd, ...)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>epoll_stl(epfd, EPOLL_CTL_ADD, listenfd, <span style=color:#f92672>&amp;</span>event);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 以下可循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>event_cnt <span style=color:#f92672>=</span> epoll_wait(epfd, ep_events, EPOLL_SIZE, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>event_cnt; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(ep_events[i].data.fd <span style=color:#f92672>==</span> listenfd){ <span style=color:#75715e>// 连接事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e># connfd = accept(...) 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		event.events <span style=color:#f92672>=</span> EPOLLIN;
</span></span><span style=display:flex><span>		event.data.fd <span style=color:#f92672>=</span> connfd;
</span></span><span style=display:flex><span>		epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, <span style=color:#f92672>&amp;</span>event);
</span></span><span style=display:flex><span>	}<span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span>(ep_events[i].events <span style=color:#f92672>&amp;</span> EPOLLIN){ <span style=color:#75715e>// 数据传输事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		str_len <span style=color:#f92672>=</span> read(ep_events[i].data.fd, buf, BUF_SIZE);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(str_len <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){ <span style=color:#75715e>// close请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			epoll_ctl(epfd, EPOLL_DEL, ep_events[i].data.fd, NULL);
</span></span><span style=display:flex><span>			close(ep_events[i].data.fd);
</span></span><span style=display:flex><span>		}<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>			write(ep_events[i].data.fd, buf, str_len);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>close(sockfd);
</span></span><span style=display:flex><span>close(epfd);
</span></span></code></pre></div><h3 id=条件触发边缘触发>条件触发（+边缘触发）
<a class=header-anchor href=#%e6%9d%a1%e4%bb%b6%e8%a7%a6%e5%8f%91%e8%be%b9%e7%bc%98%e8%a7%a6%e5%8f%91></a></h3><h1 id=socket-api>Socket API
<a class=header-anchor href=#socket-api></a></h1><table><thead><tr><th>API</th><th>作用</th><th>使用</th></tr></thead><tbody><tr><td>int socket(int family<sup>(IPV4为AF_INET; IPV6为AF_INET6; 本地通信为AF_LOCAL)</sup>, int type<sup>(UDP为SOCK_DGRAM; TCP为SOCK_STREAM)</sup>, int protocol<sup>(0,除非同一协议族中存在多个数据传输方式相同的协议)</sup>);</td><td>创建socket</td><td>listenfd = <strong>socket</strong>(AF_INET, SOCK_STREAM, 0);</td></tr><tr><td>int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);</td><td>将地址绑定到socket上</td><td><strong>bind</strong>(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</td></tr><tr><td>int listen(int sockfd, int backlog<sup>(最多允许连接数，可设置为SOMAXCONN(listen队列最大长度))</sup>);</td><td>监听socket</td><td><strong>listen</strong>(listenfd, 20);</td></tr><tr><td>int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);</td><td>申请建立连接</td><td><strong>connect</strong>(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</td></tr><tr><td>int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);</td><td>接收连接，返回连接socket</td><td>socklen_t addrlen = static_cast&lt;socklen_t>(sizeof cliaddr);<br>connfd = <strong>accept</strong>(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);<br></td></tr><tr><td>int shutdown(int sock, int howto<sup>(SHUT_RD断开输入流（无法接收）、SHUT_WR断开输出流（无法发送）、SHUT_RDWWR同时断开I/O流)</sup>);</td><td>断开单条通道</td><td><strong>shutdown</strong>(sockfd, SHUT_WR)</td></tr><tr><td>int close(int fd);</td><td>关闭socket</td><td><strong>close</strong>(sockfd)</td></tr></tbody></table><h2 id=socket地址>socket地址
<a class=header-anchor href=#socket%e5%9c%b0%e5%9d%80></a></h2><h2 id=读写>读写
<a class=header-anchor href=#%e8%af%bb%e5%86%99></a></h2><p>可以使用文件IO函数。</p><table><thead><tr><th>API</th><th>功能</th><th>使用</th></tr></thead><tbody><tr><td>ssize_t sendto(int fd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);</td><td>UDP发送数据</td><td><strong>sendto</strong>(sendfd, buf, strlen(buf), 0, (struct sockaddr *)&amp;recv_addr, sizeof(recv_addr))</td></tr><tr><td>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</td><td>UDP接收数据</td><td><strong>recvfrom</strong>(recvfd, buf, MAXLINE, 0, (struct sockaddr *)&amp;send_addr, &amp;send_addr_len)</td></tr><tr><td>int s<sup>(对端关闭连接或发送0字节数据，send才会返回0)</sup>​en<sup>(对端关闭连接或本端发送0字节数据，send才会返回0)</sup>​d<sup>(对端关闭连接或发送0字节数据，send才会返回0)</sup>(int s, const void *msg, size_t len, int flags);</td><td>TCP发送数据</td><td><strong>send</strong>(sendfd, buf, strlen(buf))</td></tr><tr><td>int recv<sup>(只有在对端关闭连接时才会返回 0，如果对端发送0字节数据，recv不会收到)</sup>(int sockfd,void *buf,int len,int flags);</td><td>TCP接收数据</td><td><strong>recv</strong>(recvfd, buf, MAXLINE)</td></tr></tbody></table><p>‍</p><h1 id=应用层>应用层
<a class=header-anchor href=#%e5%ba%94%e7%94%a8%e5%b1%82></a></h1><h2 id=httprpc>HTTP（+RPC）
<a class=header-anchor href=#httprpc></a></h2><table><thead><tr><th></th><th style=text-align:center>HTTP</th><th>RPC</th></tr></thead><tbody><tr><td></td><td style=text-align:center>超文本传输协议</td><td>远程过程调用</td></tr><tr><td>作用</td><td style=text-align:center>定义解析规则<br></td><td></td></tr><tr><td>服务发现<sup>（找到服务对应的IP和端口）</sup></td><td style=text-align:center>DNS</td><td>中间服务<sup>（consul/etcd/CoreDNS）</sup></td></tr><tr><td>底层连接</td><td style=text-align:center>长连接keep alive</td><td>长连接 + 连接池</td></tr><tr><td>传输内容</td><td style=text-align:center>JSON序列化<sup>（消息头header + 消息体body）</sup></td><td>protobuf等其他序列化协议</td></tr><tr><td>性能</td><td style=text-align:center></td><td>更好</td></tr></tbody></table><h3 id=请求报文请求方法>请求报文（+请求方法）
<a class=header-anchor href=#%e8%af%b7%e6%b1%82%e6%8a%a5%e6%96%87%e8%af%b7%e6%b1%82%e6%96%b9%e6%b3%95></a></h3><p>​<img src=/imgs/img-lazy-loading.gif data-src=https://raw.githubusercontent.com/arukasxy/notes/main/content/post/image-viewer/image-20240717125557-dlb99ci.png alt=image>​</p><blockquote><p><strong>请求方法</strong>：</p><ul><li>GET（获取资源）</li><li>POST（上传数据）</li><li>DELETE（删除资源）</li><li>HEAD（获取资源元信息）</li><li>OPTIONS（列出可对资源实行的方法）</li><li>PUT（类似于POST，替换整个资源）</li><li>PATCH（替换部分资源）</li><li>TRACE（追踪请求 - 响应的传输路径）</li><li>CONNECT（建立特殊的连接隧道）</li></ul></blockquote><table><thead><tr><th></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>参数位置</td><td>URL</td><td>报文体</td></tr><tr><td>数据长度</td><td>URL最大长度<sup>（2KB（2048个字符））</sup></td><td>无长度消毒</td></tr><tr><td>缓存<sup>（GET通常进行查询操作，POST通常将数据发送给服务器，修改和更新数据）</sup></td><td>浏览器有缓存</td><td>无缓存</td></tr><tr><td>数据类型</td><td>ASCII字符</td><td>更多字符类型</td></tr><tr><td>安全<sup>（只读，请求方法不会「破坏」服务器上的资源）</sup></td><td>安全</td><td>不安全</td></tr><tr><td>幂等<sup>（多次执行相同的操作，结果都是「相同」的）</sup></td><td>幂等</td><td>不幂等</td></tr><tr><td>安全</td><td></td><td>安全性高，不会被缓存，<br>不会保存在服务器日志和浏览记录中<br></td></tr><tr><td>功能</td><td>搜索、排序和筛选<br>等查询操作</td><td>修改和写入数据</td></tr></tbody></table><h3 id=响应报文状态码>响应报文（+状态码）
<a class=header-anchor href=#%e5%93%8d%e5%ba%94%e6%8a%a5%e6%96%87%e7%8a%b6%e6%80%81%e7%a0%81></a></h3><p>​<img src=/imgs/img-lazy-loading.gif data-src=https://raw.githubusercontent.com/arukasxy/notes/main/content/post/image-viewer/image-20240717125655-wykyz61.png alt=image>​</p><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>1xx</td><td>请求已经收到了，正在处理</td></tr><tr><td>2xx</td><td>处理成功</td></tr><tr><td>206</td><td>Partial Content客户端表明自己只需要目标URL上的部分资源的时候返回的，可实现断点续传、带宽遏流</td></tr><tr><td>3xx</td><td>重定向到其它地方<br></td></tr><tr><td>302</td><td>暂时性转移Temporarily Moved</td></tr><tr><td>4xx<br></td><td>处理发生错误，责任在客户端<br></td></tr><tr><td>5xx</td><td>处理发生错误，责任在服务端</td></tr></tbody></table><h3 id=强缓存和协商缓存>强缓存和协商缓存
<a class=header-anchor href=#%e5%bc%ba%e7%bc%93%e5%ad%98%e5%92%8c%e5%8d%8f%e5%95%86%e7%bc%93%e5%ad%98></a></h3><p>加载资源时，先检查<strong>强缓存</strong>是否命中，如果资源过期，进行<strong>协商缓存</strong>，确定资源是否有效</p><table><thead><tr><th></th><th>强缓存</th><th>协商缓存</th></tr></thead><tbody><tr><td></td><td>缓存请求过的资源</td><td>向服务器确认缓存资源是否有效</td></tr><tr><td>功能</td><td>节省带宽<br>提高访问速度<br>降低服务器压力<br></td><td>确保获取到最新资源</td></tr><tr><td>场景</td><td>静态资源<sup>（图片、CSS文件等）</sup></td><td>频繁更新的资源</td></tr><tr><td>实现</td><td>Expires过期时间<sup>（HTTP1.0）</sup><br>Cache-Control缓存有效时间<sup>（HTTP1.1,提供更灵活的缓存控制机制）</sup></td><td>ETag资源唯一标识符<br>Last-Modified资源最后修改时间<br>返回状态码</td></tr></tbody></table><h3 id=http版本>HTTP版本
<a class=header-anchor href=#http%e7%89%88%e6%9c%ac></a></h3><table><thead><tr><th></th><th>HTTP1.0</th><th>HTTP1.1</th><th>HTTP2.0</th><th>HTTP3.0</th></tr></thead><tbody><tr><td>本质</td><td><br></td><td></td><td>基于HTTPS</td><td>基于<strong>UDP</strong>的QUIC可靠协议</td></tr><tr><td>长连接<sup>（TCP 三次握手时会有 1.5 RTT 的延迟，以及建立连接后慢启动（slow-start），重复建立连接浪费时间和带宽）</sup></td><td>默认短连接</td><td>默认keep-alive<br></td><td></td><td></td></tr><tr><td>请求的管道处理<sup>（多路复用，即一个TCP连接上可以传送多个HTTP请求和响应）</sup></td><td>×</td><td>队头请求阻塞后，请求队列均阻塞<sup>（请求和响应之间没有序号标识）</sup></td><td>用流和<sup>（请求和响应消息被拆分为帧，为每个帧分配序号，独立传输）</sup>​分帧解决了<sup>（请求对应一个流，被拆分为帧，为每个帧分配序号，独立传输）</sup>​HTTP的队头阻塞<sup>（请求和响应消息被拆分为帧，为每个帧分配序号，独立传输）</sup><br>存在TCP队头阻塞<sup>（TCP分节丢失后，后序分节需保存直到重传完成）</sup><br></td><td>解决了TCP的队头阻塞<sup>（放弃了TCP）</sup></td></tr><tr><td>Header压缩</td><td></td><td></td><td>HPAK算法<sup>（在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，就不用重复发送同样字段了，只发送索引号，减少数据量提高速度）</sup></td><td></td></tr><tr><td>二进制传输</td><td>纯文本<br></td><td></td><td>二进制</td><td></td></tr><tr><td>主动通知</td><td></td><td></td><td>服务器主动向客户端发送数据</td><td></td></tr><tr><td>连接时间</td><td></td><td></td><td>TCP三次握手 + TLS握手</td><td>不需要握手</td></tr><tr><td>重传策略</td><td>初始包和重传包使用相同的sequence number，必须有序确认，加大之后重传计算的耗时<br></td><td></td><td></td><td>包使用unique packet number<sup>(唯一且单调递增)</sup>，支持乱序确认</td></tr><tr><td>连接迁移</td><td>四元组（源IP、源端口、目的IP、目的端口)任一发生变化，需重新建立连接<br></td><td></td><td></td><td>使用Connection ID维持原有连接</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>HTTPS</strong>：</p><ul><li>添加<strong>SSL/TLS</strong>安全协议，报文可以加密传输</li><li>除TCP三次握手外，需进行SSL/TLS握手</li><li>端口号为443（HTTP为80）</li><li>HTTPS协议需要向CA(证书权威机构)申请数字证书，来保证服务器的身份是可信的</li></ul><h3 id=cookie与session>Cookie与Session
<a class=header-anchor href=#cookie%e4%b8%8esession></a></h3><table><thead><tr><th></th><th>Cookie</th><th>Session</th></tr></thead><tbody><tr><td>实现</td><td>cookie存储和发送session id</td><td></td></tr><tr><td>功能</td><td>跟踪用户身份<br></td><td></td></tr><tr><td>位置</td><td>浏览器</td><td>服务器</td></tr><tr><td>安全</td><td>可以伪造</td><td>不能伪造<sup>（因为在服务器上）</sup></td></tr></tbody></table><h2 id=cdn内容分发网络>CDN内容分发网络
<a class=header-anchor href=#cdn%e5%86%85%e5%ae%b9%e5%88%86%e5%8f%91%e7%bd%91%e7%bb%9c></a></h2><p>特点：</p><ul><li>用户就近访问服务器，提升响应速度</li></ul><h1 id=传输层>传输层
<a class=header-anchor href=#%e4%bc%a0%e8%be%93%e5%b1%82></a></h1><table><thead><tr><th></th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td></td><td>面向消息的不可靠协议</td><td>面向字节流的可靠协议<br></td></tr><tr><td>端口号重复</td><td>TCP和UDP套接字可以共用端口号<br></td><td></td></tr><tr><td>连接</td><td>无连接</td><td>建立连接</td></tr><tr><td>使用</td><td>SOCK_DGRAM</td><td>SOCK_STREAM</td></tr><tr><td>大小</td><td>512字节以内</td><td></td></tr><tr><td>报文</td><td>仅一个UDP报文</td><td>将大的报文按<strong>序列号</strong>拆分与合并</td></tr><tr><td>传播</td><td>支持单播、多播、广播</td><td>仅支持单播</td></tr><tr><td>头部</td><td>仅8字节</td><td>最小20字节，最大60字节</td></tr><tr><td>数据边界</td><td>数据有边界<sup>（接收数据的次数应和传输次数相同）</sup></td><td>数据无边界</td></tr><tr><td>保持连接</td><td>每次需要添加目标地址</td><td>keep-alive</td></tr><tr><td>功能<br>（可靠性）</td><td>无</td><td>传递给应用层的数据按序交付<sup>（序列号）</sup>、不丢失<sup>（确认号、超时重传）</sup>、不重复<br>流量控制、拥塞控制</td></tr><tr><td>实现</td><td>无发送缓冲区、数据包无序号</td><td></td></tr><tr><td>场景</td><td>性能，如实时视频</td><td>可靠性，如传输文件</td></tr><tr><td>协议</td><td>DNS、TFTP、SNMP、NTP</td><td>HTTP、FTP、SMTP、TELNET、SSH</td></tr></tbody></table><h2 id=udp>UDP
<a class=header-anchor href=#udp></a></h2><h3 id=实现可靠传输>实现可靠传输
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93></a></h3><p>参考QUIC、KCP、UDT、RTP、RUDP</p><p>要求：数据不丢失、数据有序、流量控制<sup>（控制向应用层交付数据的速率, 避免应用层来不及消费数据而丢包）</sup>、拥塞控制</p><ol><li><p>自动重传请求：发送缓冲区 + 超时时间</p><p><strong>发送缓冲区<sup>（原UDP没有发送缓冲区）</sup></strong> 中暂存已经发送但没有收到确认的数据包，当超过指定时间后，自动重传该数据包</p></li><li><p>数据包添加序号</p></li><li><p>流量控制和拥塞控制参考TCP</p></li></ol><h2 id=tcp>TCP
<a class=header-anchor href=#tcp></a></h2><p>​<img src=/imgs/img-lazy-loading.gif data-src=https://raw.githubusercontent.com/arukasxy/notes/main/content/post/image-viewer/TCP-20240718110304-kwr7q9h.jpg alt=TCP>​</p><h3 id=报文解析>报文解析
<a class=header-anchor href=#%e6%8a%a5%e6%96%87%e8%a7%a3%e6%9e%90></a></h3><p>​<img src=/imgs/img-lazy-loading.gif data-src=https://raw.githubusercontent.com/arukasxy/notes/main/content/post/image-viewer/image-20240718094104-9hhevqp.png alt=image>​</p><p>​<img src=/imgs/img-lazy-loading.gif data-src=https://raw.githubusercontent.com/arukasxy/notes/main/content/post/image-viewer/image-20240718094132-8j1jkb8.png alt=image>​</p><table><thead><tr><th>标志位</th><th>含义</th></tr></thead><tbody><tr><td>URG</td><td>紧急指针</td></tr><tr><td>ACK</td><td>确认序号是否有效，置1</td></tr><tr><td>PSH</td><td>提示接收端应用程序立即从TCP缓冲区把数据读走</td></tr><tr><td>RST</td><td>重新建立连接</td></tr><tr><td>SYN</td><td>请求建立连接，置1</td></tr><tr><td>FIN</td><td>断开连接</td></tr></tbody></table><h4 id=time_wait>TIME_WAIT
<a class=header-anchor href=#time_wait></a></h4><ul><li><p>主动关闭的一方，即先发送FIN消息，进入TIME_WAIT状态</p></li><li><p><strong>持续时间</strong>：2MSL（最大报文段生存时间）</p></li><li><p><strong>原理</strong>：socket对应的四元组（源目IP、源目端口）处于冻结状态，不会释放端口</p></li><li><p><strong>作用</strong>：</p><ul><li>避免第四次挥手报文丢失造成<strong>连接关闭异常</strong>​：处于TIME_WAIT状态，则可以重新发送ACK，之后重新计时2MSL时间才会进入CLOSED状态。如果没有TIME_WAIT状态，会响应RST，导致被动关闭端异常关闭TCP连接。</li><li>避免乱序到来的报文在<strong>新的socket连接</strong>中引发混乱：假设在关闭前有TCP报文由于中间网络传输原因导致在CLOSED完成之后才到达，如果没有TIME_WAIT状态而A和B又使用同样的4元组新建了一个新的socket，那么迷路的数据包就会进入到新的socket中进行处理，可能导致业务异常。</li></ul></li><li><p>大量的TIME_WAIT：</p><ul><li><p>原因：高并发且持续的短连接请求，例如爬虫服务器、HTTP1.0</p></li><li><p>后果：端口被占用2MSL时间，占用大量CPU、内存、文件描述符、端口数量，导致新的连接无法建立</p></li><li><p>措施：</p><ul><li>socket选项设置SO_LINGER / SO_REUSEADDR</li><li>业务代码：将短连接变为长连接，如HTTP2.0</li></ul></li></ul></li></ul><h3 id=流量控制>流量控制
<a class=header-anchor href=#%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6></a></h3><ul><li>功能：控制发送端的发送速度，使其按照接收端的数据处理速度来发送数据，避免接收端处理不过来，产生网络拥塞或丢包。</li><li>实现：使用可变大小的<strong>滑动窗口</strong>来交换双方<strong>缓冲区空闲空间</strong>​信息</li><li>可发送数据大小 = min(拥塞窗口， 接收窗口) - 未确认数据大小</li></ul><h4 id=零窗口>零窗口
<a class=header-anchor href=#%e9%9b%b6%e7%aa%97%e5%8f%a3></a></h4><ul><li>接收端处理数据太慢，接收窗口为0</li></ul><p>如何通知发送端可用？</p><pre><code>使用**ZWP（Zero Window Probe，零窗口探针）** 技术，发送端收到零窗口的应答后，启动计时器，每隔一段时间问接收端。若持续返回零窗口，可能会发送RST断开连接。
</code></pre><h4 id=nagle算法>Nagle算法
<a class=header-anchor href=#nagle%e7%ae%97%e6%b3%95></a></h4><ul><li>原理：<strong>累计</strong>小数据，直到包长度大于MSS<sup>(Max Segment Size，TCP 报文段一次可传输的最大分段大小)</sup> 或者 收到前一数据的ACK，才发送下一数据</li><li>优点：避免数据报过多而发生网络过载；减少网络流量，提高网络传输效率</li><li>缺点：速度慢</li><li>适用场景：小数据块</li><li>不适用场景：传输大文件数据</li></ul><h3 id=拥塞控制>拥塞控制
<a class=header-anchor href=#%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6></a></h3><ul><li>功能：控制发送端的发送速度，避免网络拥塞</li><li>实现：维护<strong>拥塞窗口</strong>​</li><li>可发送数据大小 = min(拥塞窗口， 接收窗口) - 未确认数据大小</li></ul><p>​<img src=/imgs/img-lazy-loading.gif data-src=https://raw.githubusercontent.com/arukasxy/notes/main/content/post/image-viewer/image-20240803233035-shay5nw.png alt=image>​</p><h4 id=慢开始>慢开始
<a class=header-anchor href=#%e6%85%a2%e5%bc%80%e5%a7%8b></a></h4><ol><li>连接建立时，初始化 cwnd（拥塞窗口大小）= 1，表示可以传一个 MSS 大小的数据</li><li>每收到一个 ACK 包，cwnd++</li><li>每经过一个 RTT（往返时延），cwnd 会翻倍（指数增长）</li><li>当 cwnd >= ssthresh (slow start threshold) 时，进入拥塞避免阶段</li></ol><h4 id=拥塞避免>拥塞避免
<a class=header-anchor href=#%e6%8b%a5%e5%a1%9e%e9%81%bf%e5%85%8d></a></h4><ol><li>每收到一个 ACK 包，cwnd = cwnd + 1/cwnd</li><li>每经过一个 RTT，cwnd = cwnd + 1（加法增大）</li><li>如果触发超时重传或快速重传，则网络出现了拥塞</li></ol><h4 id=超时重传>超时重传
<a class=header-anchor href=#%e8%b6%85%e6%97%b6%e9%87%8d%e4%bc%a0></a></h4><ol><li>把 sshthresh 设为当前拥塞窗口的一半（乘法减小）</li><li>cwnd 重置为 1，重新开始慢启动过程</li></ol><h4 id=快速重传快速恢复>快速重传（快速恢复）
<a class=header-anchor href=#%e5%bf%ab%e9%80%9f%e9%87%8d%e4%bc%a0%e5%bf%ab%e9%80%9f%e6%81%a2%e5%a4%8d></a></h4><p><strong>触发时机</strong>：接收端收到乱序包时，会发送 duplicate ACK 通知发送端。当发送端收到 3 个 duplicate ACK 时，就立刻开始重传，而不必继续等待到计时器超时。</p><p><strong>原理</strong>：如果网络出现拥塞，是不会收到多个重复的 ACK 的，所以现在网络可能没有出现拥塞。</p><ol><li>把 sshthresh 设为当前拥塞窗口的一半（乘法减小）</li><li>cwnd 重置为 sshthresh，重新开始拥塞避免过程</li></ol><h3 id=粘包>粘包
<a class=header-anchor href=#%e7%b2%98%e5%8c%85></a></h3><ul><li><p>定义：连续给对端发送两个或者两个以上的数据包，对端在一次收取中收到的数据包数量可能大于 1 个，当大于 1 个时，可能是几个（包括一个）包加上某个包的部分，或者干脆就是几个完整的包在一起。</p></li><li><p>解决：区分包与包之间的边界</p><ul><li><p>固定包长的数据包：灵活性差，太少要填充，太长要分包</p></li><li><p>以指定字符（串）为包的结束标志：可能需要转义</p></li><li><p>包头 + 包体格式</p><p>包头是固定大小的，且包头中必须含有一个字段来说明接下来的包体有多大。</p><p>对端先收取包头大小字节数目（如果不够还是先缓存起来，直到收够为止），然后解析包头，根据包头中指定的包体大小来收取包体，等包体收够了，就组装成一个完整的包来处理。</p><p>​<img src=/imgs/img-lazy-loading.gif data-src=https://raw.githubusercontent.com/arukasxy/notes/main/content/post/image-viewer/image-20240804014525-9s6466d.png alt=image>​</p></li></ul></li></ul><h1 id=网络层>网络层
<a class=header-anchor href=#%e7%bd%91%e7%bb%9c%e5%b1%82></a></h1><h2 id=ipv4和ipv6>IPv4和IPv6
<a class=header-anchor href=#ipv4%e5%92%8cipv6></a></h2><table><thead><tr><th></th><th>IPv4</th><th>IPv6</th></tr></thead><tbody><tr><td>大小</td><td>32位</td><td>128位</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id=nat协议>NAT协议
<a class=header-anchor href=#nat%e5%8d%8f%e8%ae%ae></a></h2><p>网络地址转换协议</p><ul><li>目的：解决IPV4地址资源短缺</li><li>原理：数据包发送时将局域网IP转为公网IP；数据包接收是将公网IP转为局域网IP</li><li>作用：局域网中的设备共享一个公网IP</li></ul><h1 id=数据链路层>数据链路层
<a class=header-anchor href=#%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82></a></h1><h2 id=arp协议>ARP协议
<a class=header-anchor href=#arp%e5%8d%8f%e8%ae%ae></a></h2><p>地址解析协议</p><ul><li><p>作用：IP地址 -> MAC地址</p></li><li><p>主机 A 发送 IP 数据报给主机 B 途中经过了 5 个路由器。试问在 IP 数据报的发送过程中总共使用了几次 ARP？</p><p>在发送过程中，需要依次获得5个路由器的MAC地址和主机B的MAC地址。所以一共要获得6个MAC地址，即要使用6次ARP协议。</p></li></ul><h1 id=流程解读>流程解读
<a class=header-anchor href=#%e6%b5%81%e7%a8%8b%e8%a7%a3%e8%af%bb></a></h1><h2 id=ping>ping
<a class=header-anchor href=#ping></a></h2><ol><li><p>获取IP地址：</p><ul><li>域名缓存</li><li>向DNS服务器发送DNS请求报文<sup>（发送流程和第2步相同，目的IP为DNS服务器地址，目的MAC为网关MAC）</sup>（通过静态配置或DHCP学习到DNS服务器地址）</li></ul></li><li><p>发送ICMP请求报文</p><ul><li>构造ICMP请求报文<sup>（目的IP是ping的主机，目的MAC为网关，源IP为本机IP，源MAC为本机MAC）</sup></li><li>计算网段号，查询路由表，获取下一跳地址</li><li>查询ARP缓存表获取下一跳的MAC地址，如果没有就发送ARP广播</li></ul></li></ol><h2 id=输入url到显示页面>输入URL到显示页面
<a class=header-anchor href=#%e8%be%93%e5%85%a5url%e5%88%b0%e6%98%be%e7%a4%ba%e9%a1%b5%e9%9d%a2></a></h2><ol><li>请求资源是否有缓存且缓存有效</li><li>获取IP地址</li><li>和服务器建立TCP连接</li><li>发送HTTP请求报文</li><li>接收响应报文后，解析资源，渲染页面</li></ol><h2 id=dns查询过程>DNS查询过程
<a class=header-anchor href=#dns%e6%9f%a5%e8%af%a2%e8%bf%87%e7%a8%8b></a></h2><ol><li>浏览器的DNS缓存</li><li>操作系统的DNS缓存</li><li>路由器的DNS缓存</li><li><strong>本地域名服务器</strong>的DNS缓存</li><li>本地域名服务器向 <strong>根域名服务器</strong> 发出请求，返回 <strong>顶级域名服务器</strong> 的地址</li><li>本地域名服务器向 顶级域名服务器 发出请求，返回 <strong>权限域名服务器</strong> 的地址</li><li>本地域名服务器向 权限域名服务器 发出请求，返回 对应IP地址</li></ol><h1 id=字节序>字节序
<a class=header-anchor href=#%e5%ad%97%e8%8a%82%e5%ba%8f></a></h1><p>输出变量的各个字节参考输出变量的各个字节</p><table><thead><tr><th></th><th>小端</th><th>大端（网络字节序）</th></tr></thead><tbody><tr><td>数据低位</td><td>内存的低地址中</td><td>内存的高地址中</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> number <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>number)
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Little-endian!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Big-endian!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x1234</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>a;
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;%02x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>*</span>p);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;%02x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>*</span>(p <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;%02x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>*</span>(p <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e># 小端输出 34 12 00
</span></span></span><span style=display:flex><span><span style=color:#75715e># 大端输出 00 00 12
</span></span></span></code></pre></div><h2 id=转换>转换
<a class=header-anchor href=#%e8%bd%ac%e6%8d%a2></a></h2><ul><li>只有在填socket地址<code>sockaddr_in</code>​时，才需要考虑字节序</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e># 将32位的 IP地址 从 主机字节序 转为 网络字节序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>uint32_t</span> <span style=color:#a6e22e>htonl</span>(<span style=color:#66d9ef>uint32_t</span> hostlong);
</span></span><span style=display:flex><span><span style=color:#75715e># 将16位的 端口号 从 主机字节序 转为 网络字节序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>uint16_t</span> <span style=color:#a6e22e>htons</span>(<span style=color:#66d9ef>uint16_t</span> hostshort);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将32位的 IP地址 从 网络字节序 转为 主机字节序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>uint32_t</span> <span style=color:#a6e22e>ntohl</span>(<span style=color:#66d9ef>uint32_t</span> netlong);
</span></span><span style=display:flex><span><span style=color:#75715e># 将16位的 端口号 从 网络字节序 转为 主机字节序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>uint16_t</span> <span style=color:#a6e22e>ntohs</span>(<span style=color:#66d9ef>uint16_t</span> netshort);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> cliaddr;
</span></span><span style=display:flex><span>ntohs(cliaddr.sin_port)
</span></span></code></pre></div></div><footer class=post-footer><div class=post-tags><a href=/tags/%e7%bd%91%e7%bb%9c>网络</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=reward-container><div><i class="fa-solid fa-mug-hot"></i>请我喝杯咖啡吧 ヾ(^▽^*)))</div><button>
赞赏</button><div class=post-reward><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/ali-pay.png alt="arukasxy - 支付宝">
<span>支付宝</span></div><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/wechat-pay.png alt="arukasxy - 微信">
<span>微信</span></div></div></div><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
网络通信</li><li class=post-copyright-author><strong>本文作者： </strong>arukasxy</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/telecommunication-ot0ya.html title=网络通信>/post/telecommunication-ot0ya.html</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=/images/wechat_channel.jpg><span class=icon><i class="fab fa-weixin"></i>
</span><span class=label>WeChat</span></a></div><div class=social-item><a target=_blank class=social-link href=/atom.xml><span class=icon><i class="fa fa-rss"></i>
</span><span class=label>RSS</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/kind-z2cvctu.html rel=next title=类><i class="fa fa-chevron-left"></i> 类</a></div><div class="post-nav-prev post-nav-item"><a href=/post/concurrent-zcq7q0.html rel=prev title=并发>并发
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=waline-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2010 - 2024
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>arukasxy</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.131.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.6.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>粤ICP备 18047355-1 号</a>
<img src=/imgs/gongan.png alt=沪公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=31011402009770" target=_blank>沪公网安备 31011402009770 号</a></div><div class=vendors-list><a target=_blank href=https://github.com title=Github><img src=/imgs/img-lazy-loading.gif data-src=/imgs/vendors/github.svg alt=Github>
</a><span>提供CDN/云资源支持</span></div></div></footer><script type=text/javascript src=/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"/3rd"}},"version":"4.6.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o \n\n可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄\n(Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"2.15.8"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"2.15.8"}}}</script><script type=text/javascript src=/js/main.min.befa9b7d22ec90da86c74c5dbff5ee42c12e9fc6d6f4448bfcc596cc329b19e8.js defer></script></body></html>