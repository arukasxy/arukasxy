<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.131.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="内存管理"><meta itemprop=description content><meta name=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/content/post/image-viewer/touxian.png"><meta itemprop=keywords content="内存"><meta property="og:type" content="article"><meta property="og:title" content="内存管理"><meta property="og:description" content><meta property="og:image" content="/content/post/image-viewer/touxian.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/memory-management-z1c7hkf.html"><meta property="og:site_name" content="Sakura Notes"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="arukasxy"><meta property="article:published_time" content="2024-07-11 20:16:25 +0800 +0800"><meta property="article:modified_time" content="2024-08-08 13:19:17 +0800 +0800"><link type=text/css rel=stylesheet href=/3rd/font-awesome/6.6.0/css/all.min.css><link type=text/css rel=stylesheet href=/3rd/animate.css/4.1.1/animate.min.css><link type=text/css rel=stylesheet href=/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href=/css/main.min.b6d9013c78b06afe86ed98928d25ab3d998dba91fe7bfcbdca64997f35723da9.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"memory-management-z1c7hkf.html","permalink":"/post/memory-management-z1c7hkf.html","title":"内存管理","waline":{"js":[{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"2.15.8"},{"alias":"@waline/client","alias_name":"waline","file":"dist/comment.js","name":"comment","version":"2.15.8"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>内存管理 - Sakura Notes</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Sakura Notes</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>计算机,C++,数据库</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>22</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#堆和栈区别>堆和栈区别</a></li></ul><ul><li><a href=#在已分配内存上构建对象placement-new>在已分配内存上构建对象（placement new）</a></li><li><a href=#内存复制>内存复制</a></li><li><a href=#内存比较>内存比较</a></li><li><a href=#内存清零>内存清零</a></li><li><a href=#内存填充>内存填充</a></li><li><a href=#malloc分配原理>malloc分配原理</a><ul><li><a href=#sbrk拓展堆>sbrk拓展堆</a></li><li><a href=#mmap匿名映射>mmap匿名映射</a></li></ul></li></ul><ul><li><a href=#mmu内存管理单元虚拟地址映射访问控制>MMU内存管理单元（虚拟地址映射，访问控制）</a></li><li><a href=#页表快表tlb>页表（+快表TLB）</a></li></ul><ul><li><a href=#lru>LRU</a></li><li><a href=#lfu>LFU</a></li></ul><ul><li><a href=#基于顺序搜索>基于顺序搜索</a></li><li><a href=#基于索引搜索>基于索引搜索</a></li></ul><ul><li><a href=#对象池>对象池</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=arukasxy src=/imgs/img-lazy-loading.gif data-src=/content/post/image-viewer/touxian.png><p class=site-author-name itemprop=name>arukasxy</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>22</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>8</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>24</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/arukasxy title="Github → https://github.com/arukasxy" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/arukasxy rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/memory-management-z1c7hkf.html><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/content/post/image-viewer/touxian.png"><meta itemprop=name content="arukasxy"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="arukasxy"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="内存管理"><meta itemprop=description content="内存管理 内存分区 分为代码区、常量区、全局/静态区、堆区、栈区 参考进程地址空间 内存分配位置 参考：进程地址空间 代码 分配位置 char str[] 字符数组 栈或全局区"></span><header class=post-header><h1 class=post-title itemprop="name headline">内存管理</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-07-11 20:16:25 +0800 +0800" itemprop="dateCreated datePublished" datetime="2024-07-11 20:16:25 +0800 +0800">2024-07-11
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-08-08T13:19:17+08:00 itemprop=dateModified datetime=2024-08-08T13:19:17+08:00>2024-08-08</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86 itemprop=url rel=index><span itemprop=name>内存管理</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>4729</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>10分钟</span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h1 id=内存管理>内存管理
<a class=header-anchor href=#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86></a></h1><h1 id=内存分区>内存分区
<a class=header-anchor href=#%e5%86%85%e5%ad%98%e5%88%86%e5%8c%ba></a></h1><p>分为代码区、常量区、全局/静态区、堆区、栈区</p><p>参考进程地址空间</p><h1 id=内存分配位置>内存分配位置
<a class=header-anchor href=#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e4%bd%8d%e7%bd%ae></a></h1><p>参考：进程地址空间</p><table><thead><tr><th>代码</th><th></th><th>分配位置</th></tr></thead><tbody><tr><td>char str[]</td><td>字符数组</td><td>栈或全局区</td></tr><tr><td>const char str[]</td><td>字符数组<sup>（即使字符串相同，其内存地址也不同）</sup></td><td>栈或全局区</td></tr><tr><td>char *str=&ldquo;hello&rdquo;</td><td>字符常量<sup>（相同字符常量在文字常量区仅保存一份，即地址相同）</sup><br></td><td>文字常量区</td></tr><tr><td>const char *str=&ldquo;hello&rdquo;</td><td></td><td>文字常量区</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>全局初始化区</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p1;   <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>全局未初始化区</span>
</span></span><span style=display:flex><span>main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> b;  <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>栈</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> s[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abc&#34;</span>; <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>栈</span>(<span style=color:#66d9ef>char</span>[])
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p2;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p3 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;123456&#34;</span>; <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#e6db74>&#34;123456&#34;</span><span style=color:#960050;background-color:#1e0010>在常量区，</span>p3在栈上<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span><span style=color:#ae81ff>0</span><span style=color:#960050;background-color:#1e0010>；</span> <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>全局（静态）初始化区</span>
</span></span><span style=display:flex><span>  p1 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)malloc(<span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>  p2 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)malloc(<span style=color:#ae81ff>20</span>); 
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>分配得来的</span><span style=color:#ae81ff>10</span><span style=color:#960050;background-color:#1e0010>和</span><span style=color:#ae81ff>20</span><span style=color:#960050;background-color:#1e0010>字节的区域在堆区。</span>
</span></span><span style=display:flex><span>  strcpy(p1, <span style=color:#e6db74>&#34;123456&#34;</span>); <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>123456</span><span style=color:#960050;background-color:#1e0010>放在常量区，编译器可能会将它与</span>p3所指向的<span style=color:#e6db74>&#34;123456&#34;</span><span style=color:#960050;background-color:#1e0010>优化成一个地方。</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=栈内存管理stack>栈内存管理（stack）
<a class=header-anchor href=#%e6%a0%88%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86stack></a></h1><p>通过{ } 限定作用域</p><h2 id=堆和栈区别>堆和栈区别
<a class=header-anchor href=#%e5%a0%86%e5%92%8c%e6%a0%88%e5%8c%ba%e5%88%ab></a></h2><table><thead><tr><th></th><th>栈</th><th>堆</th></tr></thead><tbody><tr><td>场景</td><td>小块、频繁的内存分配</td><td>延长变量的生命周期；栈中没有足够的空间</td></tr><tr><td>生长方向</td><td>向低地址增长</td><td>向高地址增长</td></tr><tr><td>容量</td><td>比较小，如8M<sup>(Linux 上通过 ulimit -s 查看)</sup></td><td>和虚拟内存相关</td></tr><tr><td>分配效率</td><td>软硬件<sup>（push和pop指令、rbp和rsp寄存器，）</sup>​结合优<sup>（push和pop指令、rbp和rsp寄存器）</sup>​化<sup>（push和pop指令、rbp和rsp寄存器，）</sup>，效率高</td><td></td></tr><tr><td>内存碎片</td><td>连续分配</td><td>不连续的，有内存碎片</td></tr><tr><td>分配回收</td><td>自动</td><td>手动</td></tr></tbody></table><p>例子：</p><ul><li>string中在栈中分配空间给小字符串（&lt;=15个字符的字符串）</li></ul><h1 id=堆内存管理newmalloc>堆内存管理（new/malloc）
<a class=header-anchor href=#%e5%a0%86%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86newmalloc></a></h1><table><thead><tr><th></th><th>new</th><th>malloc<sup>(#include &lt;stdlib.h>)</sup></th></tr></thead><tbody><tr><td>内存大小计算</td><td>new A;</td><td>(A *)malloc(sizeof(A));</td></tr><tr><td>返回类型转换</td><td>对象类型的指针，无需进行类型转换</td><td>void*</td></tr><tr><td>函数重载</td><td>支持</td><td>不支持</td></tr><tr><td>重新分配内存</td><td>不支持</td><td>realloc(pa, N<em>sizeof(A))<sup>(将指针pa所指向的已分配内存区的大小拓展为N</em>sizeof(A))</sup></td></tr><tr><td>分配内存并初始化</td><td>new + 调用构造函数</td><td>(A <em>)calloc(N, sizeof(A));<sup>(申请N</em>sizeof(A)大小的空间;malloc分配的内存没有初始化)</sup><br>空间初始化为0</td></tr><tr><td>内存分配失败</td><td>默认抛出异常 catch (const std::bad_alloc& e)<br>或使用new(std::nothrow) 后判断NULL</td><td>返回NULL</td></tr><tr><td>数组分配</td><td>new[]</td><td>malloc(N*sizeof(A))<sup>(手动计算数组大小)</sup></td></tr><tr><td>可重入</td><td></td><td>不可重入<sup>（有全局内存分配表）</sup></td></tr><tr><td>释放内存</td><td>delete</td><td>free</td></tr></tbody></table><h2 id=在已分配内存上构建对象placement-new>在已分配内存上构建对象（placement new）
<a class=header-anchor href=#%e5%9c%a8%e5%b7%b2%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98%e4%b8%8a%e6%9e%84%e5%bb%ba%e5%af%b9%e8%b1%a1placement-new></a></h2><p>特点：</p><ul><li>作用：允许将object构建于allocated memory中</li><li>预分配内存，构建对象速度快，避免内存碎片</li><li>不需要delete，需要显式调用析构函数</li><li>可以在<strong>栈 或 堆</strong>上构建对象</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> buff <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span>[ <span style=color:#66d9ef>sizeof</span>(Foo) <span style=color:#f92672>*</span> N ];
</span></span><span style=display:flex><span>memset( buff, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(Foo)<span style=color:#f92672>*</span>N );
</span></span><span style=display:flex><span>Foo<span style=color:#f92672>*</span> pfoo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> (buff)Foo;
</span></span><span style=display:flex><span>pfoo<span style=color:#f92672>-&gt;</span>print();
</span></span><span style=display:flex><span>pfoo<span style=color:#f92672>-&gt;~</span>Foo();
</span></span><span style=display:flex><span><span style=color:#66d9ef>delete</span> [] buff;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 对象数组（构造参数带参数）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> pong <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span>[ <span style=color:#66d9ef>sizeof</span>(CPong) <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span> ];
</span></span><span style=display:flex><span>CPong<span style=color:#f92672>*</span> pp <span style=color:#f92672>=</span> (CPong<span style=color:#f92672>*</span>)pong;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> ( <span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>10</span>; <span style=color:#f92672>++</span>i ){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> (pp<span style=color:#f92672>+</span>i)CPong(i);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> ( <span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; j<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>10</span>; <span style=color:#f92672>++</span>j )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    pp[j].<span style=color:#f92672>~</span>CPong();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>delete</span> [] pong;
</span></span></code></pre></div><h2 id=内存复制>内存复制
<a class=header-anchor href=#%e5%86%85%e5%ad%98%e5%a4%8d%e5%88%b6></a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e># 对有析构函数等的非POD类型使用 = 拷贝构造函数
</span></span></span><span style=display:flex><span><span style=color:#75715e># 对保存非POD类型的数组等容器使用 std::copy,参考STL算法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> source[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> dest[<span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>copy(std<span style=color:#f92672>::</span>begin(source),std<span style=color:#f92672>::</span>end(source),std<span style=color:#f92672>::</span>begin(dest));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 源区域和目标区域 无 重叠
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>memcpy(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>source, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dest, size_t n)
</span></span><span style=display:flex><span><span style=color:#75715e>// n为复制的字节数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e># 源区域和目标区域 可能 重叠
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>memmove(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dest, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>source, size_t n)
</span></span><span style=display:flex><span><span style=color:#75715e>// memmove() 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，复制后源区域的内容会被更改
</span></span></span></code></pre></div><h2 id=内存比较>内存比较
<a class=header-anchor href=#%e5%86%85%e5%ad%98%e6%af%94%e8%be%83></a></h2><ul><li>比strncmp效率高（不检查是否结束）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> memcmp (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>a1, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>a2, size_t size)
</span></span><span style=display:flex><span><span style=color:#75715e>// 相等返回0
</span></span></span></code></pre></div><h2 id=内存清零>内存清零
<a class=header-anchor href=#%e5%86%85%e5%ad%98%e6%b8%85%e9%9b%b6></a></h2><ul><li>bzero将前n个字节置0</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bzero</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>s, <span style=color:#66d9ef>int</span> n);
</span></span><span style=display:flex><span>bzero(<span style=color:#f92672>&amp;</span>serveraddr,<span style=color:#66d9ef>sizeof</span>(serveraddr));
</span></span><span style=display:flex><span>memset(<span style=color:#f92672>&amp;</span>dp,<span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>sizeof</span>(dp));
</span></span></code></pre></div><h2 id=内存填充>内存填充
<a class=header-anchor href=#%e5%86%85%e5%ad%98%e5%a1%ab%e5%85%85></a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e># 将dest的前n个字节填充为 val的最低一个字节
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>memset</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dest, <span style=color:#66d9ef>int</span> val, size_t n)
</span></span><span style=display:flex><span>memset(<span style=color:#f92672>&amp;</span>dp,<span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>sizeof</span>(dp)); 
</span></span></code></pre></div><h2 id=malloc分配原理>malloc分配原理
<a class=header-anchor href=#malloc%e5%88%86%e9%85%8d%e5%8e%9f%e7%90%86></a></h2><ol><li>使用内存匹配算法查看malloc的<code>内存池</code>​（多个空闲链表）中是否有合适的空闲区块</li><li>默认$>=128KB$使用 <strong>mmap</strong>，$&lt;128KB$使用 <strong>sbrk</strong></li><li>​<code>128KB</code>​可通过<code>mallopt()</code>​调整阈值<code>M_MMAP_THRESHOLD</code>​</li><li>每个空闲区块<strong>首部</strong>有内存控制块mem_control_block，记录元信息（指向下一个分配块的指针、当前分配块的长度、或者当前区块是否已经被分配出去）</li></ol><h3 id=sbrk拓展堆>sbrk拓展堆
<a class=header-anchor href=#sbrk%e6%8b%93%e5%b1%95%e5%a0%86></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>brk</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>addr);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sbrk</span>(intptr_t increment);
</span></span></code></pre></div><ul><li><strong>sbrk</strong>拓展堆，返回新的堆顶指针brk；</li><li>拓展的空闲空间交给<code>malloc</code>​管理</li><li>sbrk分配的内存需要等到<strong>高地址内存释放</strong>后才能释放，会产生内存碎片</li><li>最高地址空间的空闲内存超过128KB（M_TRIM_THRESHOLD）时，执行内存紧缩操作<code>trim</code>​</li></ul><h3 id=mmap匿名映射>mmap匿名映射
<a class=header-anchor href=#mmap%e5%8c%bf%e5%90%8d%e6%98%a0%e5%b0%84></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/mman.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mmap</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>addr, size_t length, <span style=color:#66d9ef>int</span> prot, <span style=color:#66d9ef>int</span> flags, <span style=color:#66d9ef>int</span> fd, off_t offset); <span style=color:#75715e>// 映射磁盘文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>munmap</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>addr, size_t length); <span style=color:#75715e>// 匿名映射
</span></span></span></code></pre></div><ul><li><strong>mmap</strong>在堆和栈之间（文件映射区域）向下拓展，而堆向上拓展</li><li>mmap分配的内存会被<strong>初始化</strong>为0</li><li>mmap分配的内存可以<strong>单独释放</strong>，减少内存碎片</li></ul><h1 id=虚拟内存>虚拟内存
<a class=header-anchor href=#%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98></a></h1><p>作用：</p><ol><li>内存保护：保护进程的空间不被其他进程破坏。</li><li>简化内存管理：所有进程拥有一致的地址空间，简化了链接、加载、内存共享等过程，解决了多进程之间地址冲突的问题。</li><li>进程的运行内存可以超过物理内存大小（swap）</li></ol><p>特点：</p><ul><li>虚存容量 = min (2^计算机位数， 内存＋外存);</li><li>32位计算机的内存空间为4G（字长）</li></ul><h2 id=mmu内存管理单元虚拟地址映射访问控制>MMU内存管理单元（虚拟地址映射，访问控制）
<a class=header-anchor href=#mmu%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e5%8d%95%e5%85%83%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e6%98%a0%e5%b0%84%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6></a></h2><p>特点：</p><ul><li>作用：将虚拟地址映射为物理地址</li><li>检查CPU处于用户态还是内核态，以及访问内存的目的（读数据、写数据、读指令），根据权限（页表中设置页面权限为可读、可写、可执行），来决定允许访问还是产生异常</li></ul><p>工作方式：</p><ol><li>操作系统在初始化或分配、释放内存时会执行一些指令在物理内存中<strong>填写</strong>页表<strong>或段表</strong>​，然后用指令设置MMU，告诉MMU页表或段表在物理内存中的什么位置<sup>（页表基地址寄存器）</sup>。</li><li>设置好之后，CPU每次执行访问内存的指令都会自动触发MMU做查表和地址转换操作，地址转换操作由硬件自动完成，不需要用指令控制MMU去做。</li></ol><h2 id=页表快表tlb>页表（+快表TLB）
<a class=header-anchor href=#%e9%a1%b5%e8%a1%a8%e5%bf%ab%e8%a1%a8tlb></a></h2><p>页表：分级，一般为4级页表；存储虚拟地址和物理地址的映射关系</p><p>快表：页表的高速缓存；提高地址转换速度</p><ul><li><p>什么时候flush快表：建立映射关系flush对应的TLB表项；进程切换可能<sup>（当ASID分配完后，flush所有TLB，重新分配ASID）</sup>flush整个TLB表</p></li><li><p>不同进程对应相同的虚拟地址，在 TLB 是如何区分的？</p><p>为每个进程分配一个ASID，可以区分不同的进程的TLB表项，就可以避免flush TLB</p></li></ul><h1 id=页面置换算法>页面置换算法
<a class=header-anchor href=#%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95></a></h1><table><thead><tr><th></th><th>原理</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>最近未使用NRU</td><td>被访问设置R，被修改设置M<br>分成四类：0<sup>(没有被访问，没有被修改)</sup>、M<sup>(没有被访问，已被修改)</sup>、R<sup>(已被访问，没有被修改)</sup>、RM<sup>(已被访问，已被修改)</sup><br>随机地从类编号最小的非空类中挑选一个页面淘汰<br></td><td></td><td></td></tr><tr><td>先进先出FIFO</td><td></td><td>简单<br>适用于仅用一次的数据<sup>（数据库全表扫描使用环形的缓冲区）</sup>、有时效性的数据<br></td><td>可能将重要的页换出</td></tr><tr><td>第二次机会SC</td><td>将页面换出内存前检查其使用位<sup>（使用时置1）</sup>，如果为1，将其置0后检查下一个页面</td><td>避免FIFO将重要的页换出内存</td><td></td></tr><tr><td>最近最少未使用LRU</td><td>局部性原理<sup>（果一个页面很久没有被访问，那么将来被访问的可能性也比较小。）</sup><br></td><td>效果好</td><td>开销大；缓存污染<sup>（由于偶发性或周期性的冷数据批量查询，热点数据被换出去，导致缓存命中率下降）</sup></td></tr><tr><td>LRU-K</td><td>最近使用过 K 次，使用历史队列<sup>（页面访问次数没有到达K次的页面，使用其他缓存策略（LRU/FIFO））</sup>和缓存队列</td><td>降低缓存污染</td><td></td></tr><tr><td>时钟CLOCK</td><td>第二次机会SC + 环形链表</td><td>避免了移动链表节点的开销</td><td></td></tr><tr><td>最不常用NFU/LFU</td><td>记录页面访问次数，优先淘汰最近访问频率最少的数据。</td><td>避免缓存污染<br>适用于<strong>访问模式固定</strong>的数据</td><td>访问模式变化时需要较长时间调整；开销大</td></tr><tr><td>最优OPT</td><td>将下一次使用时间离现在最长的页换出</td><td>作为衡量标准</td><td>不可实现</td></tr><tr><td>随机Random</td><td></td><td>简单<br>适用于对缓存key方向概率相等</td><td></td></tr></tbody></table><h2 id=lru>LRU
<a class=header-anchor href=#lru></a></h2><p>原理：使用 哈希表 来记录key在list双端链表中的位置（即迭代器）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LRUCache</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    LRUCache(<span style=color:#66d9ef>int</span> capacity) {
</span></span><span style=display:flex><span>        size <span style=color:#f92672>=</span> capacity;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>get</span>(<span style=color:#66d9ef>int</span> key) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(mp.find(key)<span style=color:#f92672>==</span>mp.end()) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> mp.find(key);
</span></span><span style=display:flex><span>        cache.splice(cache.begin(),cache,it<span style=color:#f92672>-&gt;</span>second);
</span></span><span style=display:flex><span><span style=color:#75715e>// list1.splice(position, list2, iter): 将list2中某个位置的迭代器iter指向的元素剪贴到list1中的position位置；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> it<span style=color:#f92672>-&gt;</span>second<span style=color:#f92672>-&gt;</span>second;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>put</span>(<span style=color:#66d9ef>int</span> key, <span style=color:#66d9ef>int</span> value) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> mp.find(key);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(it<span style=color:#f92672>!=</span>mp.end()){
</span></span><span style=display:flex><span>            it<span style=color:#f92672>-&gt;</span>second<span style=color:#f92672>-&gt;</span>second <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>            cache.splice(cache.begin(),cache,it<span style=color:#f92672>-&gt;</span>second);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> ;  
</span></span><span style=display:flex><span>        }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>            cache.push_front(make_pair(key,value));
</span></span><span style=display:flex><span>            mp[key] <span style=color:#f92672>=</span> cache.begin();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(mp.size()<span style=color:#f92672>&gt;</span>size){
</span></span><span style=display:flex><span>                mp.erase(cache.back().first);
</span></span><span style=display:flex><span>                cache.pop_back();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    list<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> cache;
</span></span><span style=display:flex><span>    unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,list<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;::</span>iterator<span style=color:#f92672>&gt;</span> mp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Your LRUCache object will be instantiated and called as such:
</span></span></span><span style=display:flex><span><span style=color:#75715e> * LRUCache* obj = new LRUCache(capacity);
</span></span></span><span style=display:flex><span><span style=color:#75715e> * int param_1 = obj-&gt;get(key);
</span></span></span><span style=display:flex><span><span style=color:#75715e> * obj-&gt;put(key,value);
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span></code></pre></div><h2 id=lfu>LFU
<a class=header-anchor href=#lfu></a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> { <span style=color:#75715e>// 缓存的节点信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> key, val, freq;
</span></span><span style=display:flex><span>    Node(<span style=color:#66d9ef>int</span> _key,<span style=color:#66d9ef>int</span> _val,<span style=color:#66d9ef>int</span> _freq)<span style=color:#f92672>:</span> key(_key), val(_val), freq(_freq){}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LFUCache</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> minfreq, capacity;
</span></span><span style=display:flex><span>    unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, list<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;::</span>iterator<span style=color:#f92672>&gt;</span> key_table;
</span></span><span style=display:flex><span>    unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, list<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;&gt;</span> freq_table;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    LFUCache(<span style=color:#66d9ef>int</span> _capacity) {
</span></span><span style=display:flex><span>        minfreq <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        capacity <span style=color:#f92672>=</span> _capacity;
</span></span><span style=display:flex><span>        key_table.clear();
</span></span><span style=display:flex><span>        freq_table.clear();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>get</span>(<span style=color:#66d9ef>int</span> key) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (capacity <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> key_table.find(key);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (it <span style=color:#f92672>==</span> key_table.end()) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        list<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;::</span>iterator node <span style=color:#f92672>=</span> it <span style=color:#f92672>-&gt;</span> second;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> val <span style=color:#f92672>=</span> node <span style=color:#f92672>-&gt;</span> val, freq <span style=color:#f92672>=</span> node <span style=color:#f92672>-&gt;</span> freq;
</span></span><span style=display:flex><span>        freq_table[freq].erase(node);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (freq_table[freq].size() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            freq_table.erase(freq);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (minfreq <span style=color:#f92672>==</span> freq) minfreq <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 插入到 freq + 1 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        freq_table[freq <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>].push_front(Node(key, val, freq <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        key_table[key] <span style=color:#f92672>=</span> freq_table[freq <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>].begin();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> val;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>put</span>(<span style=color:#66d9ef>int</span> key, <span style=color:#66d9ef>int</span> value) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (capacity <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> key_table.find(key);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (it <span style=color:#f92672>==</span> key_table.end()) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 缓存已满，需要进行删除操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (key_table.size() <span style=color:#f92672>==</span> capacity) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 通过 minFreq 拿到 freq_table[minFreq] 链表的末尾节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>auto</span> it2 <span style=color:#f92672>=</span> freq_table[minfreq].back();
</span></span><span style=display:flex><span>                key_table.erase(it2.key);
</span></span><span style=display:flex><span>                freq_table[minfreq].pop_back();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (freq_table[minfreq].size() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                    freq_table.erase(minfreq);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } 
</span></span><span style=display:flex><span>            freq_table[<span style=color:#ae81ff>1</span>].push_front(Node(key, value, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>            key_table[key] <span style=color:#f92672>=</span> freq_table[<span style=color:#ae81ff>1</span>].begin();
</span></span><span style=display:flex><span>            minfreq <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 与 get 操作基本一致，除了需要更新缓存的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            list<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;::</span>iterator node <span style=color:#f92672>=</span> it <span style=color:#f92672>-&gt;</span> second;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> freq <span style=color:#f92672>=</span> node <span style=color:#f92672>-&gt;</span> freq;
</span></span><span style=display:flex><span>            freq_table[freq].erase(node);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (freq_table[freq].size() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                freq_table.erase(freq);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (minfreq <span style=color:#f92672>==</span> freq) minfreq <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            freq_table[freq <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>].push_front(Node(key, value, freq <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>            key_table[key] <span style=color:#f92672>=</span> freq_table[freq <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>].begin();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h1 id=内存泄漏>内存泄漏
<a class=header-anchor href=#%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f></a></h1><ol><li><p>使用valgrind、dmalloc、efence、cppcheck等工具</p></li><li><p>使用内存火焰图，截取两个时间点的内存使用情况，两者之差是可能出现内存泄漏的地方</p></li><li><p>VS提供<code>C Runtime</code>​调试工具</p></li><li><p>编译器插件，即编译时添加<code>-fsanitize=address</code>​</p></li><li><p>使用智能指针，注意避免shared_ptr循环引用</p></li><li><p>使用RAII技术 或 保证异常安全</p></li><li><p>重载malloc，不推荐重载operator new</p><ul><li><p>operator new和operator delete有很多版本</p><p><a href=https://en.cppreference.com/w/cpp/memory/new/operator_new title="operator new, operator new[] - cppreference.com" rel="noopener external nofollow noreferrer" target=_blank class=exturl>operator new, operator new[] - cppreference.com
<i class="fa fa-external-link-alt"></i></a></p></li><li><p>线程安全</p></li></ul><p><a href=https://github.com/adah1972/nvwa title="GitHub - adah1972/nvwa: My small collection of C++ utilities" rel="noopener external nofollow noreferrer" target=_blank class=exturl>GitHub - adah1972/nvwa: My small collection of C++ utilities
<i class="fa fa-external-link-alt"></i></a></p><p><a href=http://wyw.dcweb.cn/leakage.htm title="A Cross-Platform Memory Leak Detector (dcweb.cn)" rel="noopener external nofollow noreferrer" target=_blank class=exturl>A Cross-Platform Memory Leak Detector (dcweb.cn)
<i class="fa fa-external-link-alt"></i></a></p></li></ol><h1 id=内存分配优化>内存分配优化
<a class=header-anchor href=#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e4%bc%98%e5%8c%96></a></h1><ol><li>使用<code>tcmalloc</code>​等内存分配器，会针对多线程场景优化</li><li>使用内存火焰图查看频繁进行内存分配和释放的位置</li><li>一次性malloc大块内存<sup>（减少cookie数量，减少系统调用次数）</sup>，使用freelist代替分配和回收操作，从大块内存或freelist中分配</li><li>使用内存池或对象池</li></ol><h1 id=内存分配技术存储模式>内存分配技术（存储模式）
<a class=header-anchor href=#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e6%8a%80%e6%9c%af%e5%ad%98%e5%82%a8%e6%a8%a1%e5%bc%8f></a></h1><table><thead><tr><th>段式</th><th>页式</th><th>段页式</th></tr></thead><tbody><tr><td>按逻辑意义分段</td><td>页大小固定</td><td>先分段，再分页<sup>（先把程序按照逻辑意义分成段，然后每个段再分成固定大小的页）</sup></td></tr><tr><td>没有内碎片<sup>（段大小可变，改变段大小来消除内碎片）</sup></td><td>有<sup>（只在每个进程的最后一个页框中存在内部碎片，一个页可能填充不满）</sup>​内碎片<sup>（只在每个进程的最后一个页中存在内部碎片，一个页可能填充不满）</sup></td><td></td></tr><tr><td>有外碎片<sup>（段换入换出时，比如4k的段换5k的段，会产生1k的外碎片）</sup></td><td>没有外碎片<sup>（页的大小固定）</sup></td><td></td></tr><tr><td>有利于动态链接</td><td></td><td></td></tr></tbody></table><h1 id=内存匹配算法动态分区匹配>内存匹配算法（动态分区匹配）
<a class=header-anchor href=#%e5%86%85%e5%ad%98%e5%8c%b9%e9%85%8d%e7%ae%97%e6%b3%95%e5%8a%a8%e6%80%81%e5%88%86%e5%8c%ba%e5%8c%b9%e9%85%8d></a></h1><h2 id=基于顺序搜索>基于顺序搜索
<a class=header-anchor href=#%e5%9f%ba%e4%ba%8e%e9%a1%ba%e5%ba%8f%e6%90%9c%e7%b4%a2></a></h2><table><thead><tr><th>算法</th><th>思想</th><th>分区排列方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首次适应算法<br>First Fit</td><td>从头到尾寻找合适的分区</td><td>地址递增次序</td><td>性能好，回收分区后不需要对分区重新排序；<br>高地址保留更大的分区</td><td>低地址产生外碎片；<br>每次查找都是从低址部分开始的<br></td></tr><tr><td>最佳适应算法<br>Best Fit</td><td>优先使用更小的分区</td><td>容量递增次序</td><td>保留更大的分区，满足大进程的需求</td><td>产生外碎片<sup>（采用内存紧凑来减少外部碎片，但移动代码和数据需要耗时）</sup>；回收分区后需要排序</td></tr><tr><td>最坏适应算法<br>最大适应算法<br></td><td>优先使用更大的分区</td><td>容量递减次序</td><td>减少外碎片</td><td>大分区用完后，不利于大进程；回收分区后需要排序</td></tr><tr><td>临近适应算法<br>Next Fit</td><td>每次从上次查找结束的位置开始查找</td><td>地址递增次序<br>(循环链表)</td><td>性能好，回收分区后不需要对分区重新排序；<br>不需要每次从低地址的小分区开始搜索</td><td>高地址的大分区会被用完</td></tr></tbody></table><h2 id=基于索引搜索>基于索引搜索
<a class=header-anchor href=#%e5%9f%ba%e4%ba%8e%e7%b4%a2%e5%bc%95%e6%90%9c%e7%b4%a2></a></h2><table><thead><tr><th>算法</th><th>思想</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>快速适应算法<br>分离适配<br>Quick Fit<br></td><td>为相同容量的分区单独设置空闲分区链表，建立索引表管理所有分区链表</td><td>不产生碎片；<br>查找效率高</td><td>回收算法时合并分区算法开销大</td></tr><tr><td>伙伴系统<br>Buddy System</td><td>分区大小必须为2的幂；<br>当需要的内存空间大于当前分区的一半的时候就将整个分区分配给进程，否则将分区对半分开<br></td><td>不产生外碎片；<br>适合大内存分配；<br>快速搜索、快速合并;<br>申请内存大于4M，OS尽量分配连续页面<br></td><td>满足伙伴关系的块才能合并;<br>申请内存不是2的幂会产生内碎片;<br>拆分和合并开销大</td></tr><tr><td>哈希算法</td><td>建立以空闲分区大小为关键词的哈希表</td><td></td><td></td></tr></tbody></table><h1 id=内存池>内存池
<a class=header-anchor href=#%e5%86%85%e5%ad%98%e6%b1%a0></a></h1><p>内存池管理内存块，内存块大小可能与对象大小不一致，产生内碎片</p><h2 id=对象池>对象池
<a class=header-anchor href=#%e5%af%b9%e8%b1%a1%e6%b1%a0></a></h2><p>对象池管理某个类的对象的内存管理</p><h1 id=raii>RAII
<a class=header-anchor href=#raii></a></h1><p>资源获取即初始化</p><p>思想：<strong>利用栈上局部变量的自动析构来保证资源一定会被释放</strong>。将资源和对象的声明周期绑定。</p><p>例子：lock_guard、智能指针</p><ol><li>设计一个类封装资源</li><li>在构造函数中执行资源的初始化</li><li>在析构函数中执行销毁操作</li></ol></div><footer class=post-footer><div class=post-tags><a href=/tags/%e5%86%85%e5%ad%98>内存</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=reward-container><div><i class="fa-solid fa-mug-hot"></i>请我喝杯咖啡吧 ヾ(^▽^*)))</div><button>
赞赏</button><div class=post-reward><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/ali-pay.png alt="arukasxy - 支付宝">
<span>支付宝</span></div><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/wechat-pay.png alt="arukasxy - 微信">
<span>微信</span></div></div></div><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
内存管理</li><li class=post-copyright-author><strong>本文作者： </strong>arukasxy</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/memory-management-z1c7hkf.html title=内存管理>/post/memory-management-z1c7hkf.html</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=/images/wechat_channel.jpg><span class=icon><i class="fab fa-weixin"></i>
</span><span class=label>WeChat</span></a></div><div class=social-item><a target=_blank class=social-link href=/atom.xml><span class=icon><i class="fa fa-rss"></i>
</span><span class=label>RSS</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/linux-hqnng.html rel=next title=Linux><i class="fa fa-chevron-left"></i> Linux</a></div><div class="post-nav-prev post-nav-item"><a href=/post/cmake-1gbot7.html rel=prev title=cmake>cmake
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=waline-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2010 - 2024
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>arukasxy</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.131.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.6.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>粤ICP备 18047355-1 号</a>
<img src=/imgs/gongan.png alt=沪公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=31011402009770" target=_blank>沪公网安备 31011402009770 号</a></div><div class=vendors-list><a target=_blank href=https://github.com title=Github><img src=/imgs/img-lazy-loading.gif data-src=/imgs/vendors/github.svg alt=Github>
</a><span>提供CDN/云资源支持</span></div></div></footer><script type=text/javascript src=/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"/3rd"}},"version":"4.6.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o \n\n可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄\n(Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"2.15.8"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"2.15.8"}}}</script><script type=text/javascript src=/js/main.min.b885f059fe14a6837528fa12c60e7c6fa49bb20f3dcc911617484281d3b857a1.js defer></script></body></html>