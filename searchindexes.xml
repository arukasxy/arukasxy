<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>元组</title><url>/post/turtle-1geggg.html</url><categories><category>数据结构</category></categories><tags><tag>tuple</tag><tag>pair</tag></tags><content type="html"><![CDATA[  元组 STL通常没有实现对应的哈希函数，因此在使用unordered_map/unordered_set时不能直接使用 pair对值 #include &lt;utility&gt; std::pair&lt;int, char&gt; mypair(std::make_pair(20, &#39;b&#39;)); mypair.first; mypair.second; # 接收pair对象 std::tie(name, ages) = func(); auto [a,b] = make_pair(2, 3); tuple元组 #include &lt;tuple&gt; std::tuple&lt;int, char&gt; mytuple(std::make_tuple(20, &#39;b&#39;)) # 接收tuple对象 std::get&lt;0&gt;(mytuple) = 100; auto [a, b, c] = mytuple; std::tie(a, b, c) = std::make_tuple(&#34;Tom&#34;, 20, 1.75); 展开为函数参数 可变参数模板参考可变参数，需C++17支持
# 配合函数使用 int sum(int a, int b, int c) { return a + b + c; } std::tuple&lt;int,int,int&gt; t(1,2,3); # sum为可调用对象 int res = std::apply(sum, std::move(t)); # 配合可变参数模板使用，注意使用lambda封装，使用auto自动类型推导 #include &lt;iostream&gt; #include &lt;tuple&gt; #include &lt;utility&gt; using namespace std; template&lt;typename T&gt; T sum(T t) { return t; } template&lt;typename T, typename... Types&gt; T sum(T first, Types... rest) { return first + sum&lt;T&gt;(rest...); } int main(){ std::tuple&lt;int,int,int&gt; t(1, 2, 3); cout&lt;&lt; std::apply([](auto &amp;&amp;... args) {return sum(args...);},std::move(t))&lt;&lt;endl; return 0; } # 配合仿函数使用 struct TT { int sum(int a, int b, int c) { return a + b + c; } }; int main(int argc, const char *argv[]) { std::tuple tu(TT(), 1, 2, 3); // 第一个成员就是调用成员 int res = std::apply(&amp;TT::sum, std::move(tu)); // 这里传成员函数指针 // 等同于std::get&lt;0&gt;(tu).sum(1, 2, 3) std::cout &lt;&lt; res &lt;&lt; std::endl; return 0; } # 配合匿名函数使用 std::tuple&lt;int, std::string, float&gt; t1(10, &#34;Test&#34;, 3.14); std::apply([](auto&amp;&amp;... args) { ((std::cout &lt;&lt; args &lt;&lt; &#39;\n&#39;), ...); }, t1); 展开为构造函数参数 class Test { public: Test(int a, double b, const std::string &amp;c): a_(a), b_(b), c_(c) {} void show() const {std::cout &lt;&lt; a_ &lt;&lt; &#34; &#34; &lt;&lt; b_ &lt;&lt; &#34; &#34; &lt;&lt; c_ &lt;&lt; std::endl;} private: int a_; double b_; std::string c_; }; // 自行封装构造过程 template &lt;typename T, typename... Args&gt; T Create(Args &amp;&amp;...args) { return T(args...); } int main(int argc, const char *argv[]) { std::tuple tu(1, 2.5, &#34;abc&#34;); # 1. 使用make_form_tuple Test &amp;&amp;t = std::make_from_tuple&lt;Test&gt;(std::move(tu)); # 2. 使用自己的封装结构 Create Test &amp;&amp;t = std::apply([](auto &amp;&amp;...args)-&gt;Test {return Create&lt;Test&gt;(args...);}, std::move(tu)); t.show(); // 打印：1 2.5 abc return 0; }   ]]></content></entry><entry><title>queue队列</title><url>/post/queue-queue-z1b93g7.html</url><categories/><tags/><content type="html"><![CDATA[  queue队列 queue队列 底层实现 支持empty，size，front，back，push_back，pop_front 的容器
底层容器：deque（默认）、list
成员函数 函数 功能 front() 头部元素 back() 尾部元素 push() 尾部插入 pop() 删除头部 priority_queue优先级队列 #include &lt;queue&gt; # 最小堆，队头为最小值 priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; pq; pq.emplace(elem); pq.push(elem); pq.pop(); 底层实现 支持empty, size, front, push_back, pop_back 的容器
底层容器：vector（默认，结合堆算法）、deque
环形队列 rear指定队尾元素的后一位置
判断是否为空：front == rear
判断是否为满：front == (rear+1)%capacity
元素个数：
用数组C[1..m]表示的环形队列，m为数组的长度。假设f为队头元素在数组中的位置，r为队尾元素的后一位置（按顺时针方向）。若队列非空，则计算队列中元素个数的公式应为？$( m+r-f ) % m$
class MyCircularQueue { private: int front; int rear; int capacity; vector&lt;int&gt; elements; public: MyCircularQueue(int k) { this-&gt;capacity = k + 1; this-&gt;elements = vector&lt;int&gt;(capacity); rear = front = 0; } bool enQueue(int value) { // 增加一个元素，在堆尾rear插入 if (isFull()) { return false; } elements[rear] = value; rear = (rear + 1) % capacity; return true; } bool deQueue() { // 删除一个元素，在堆首front插入 if (isEmpty()) { return false; } front = (front + 1) % capacity; //循环队列 index+1如何处理 return true; } int Front() { if (isEmpty()) { return -1; } return elements[front]; } int Rear() { if (isEmpty()) { return -1; } return elements[(rear - 1 + capacity) % capacity]; //循环队列 index-1如何处理 } bool isEmpty() { return rear == front; } bool isFull() { return ((rear + 1) % capacity) == front; } }; deque双端队列 特点：支持任意位置的元素插入和删除；支持随机访问 实现：分段连续空间 #include &lt;deque&gt; deque&lt;string&gt; deq; 成员函数 函数 功能 push_back() 尾部插入 push_front() 头部插入 insert() 插入 pop_back() 尾部删除 pop_front() 头部删除 deq[1] 随机访问   ]]></content></entry><entry><title>关于 Hugo NexT 组织</title><url>/about.html</url><categories/><tags/><content type="html">  Hugo NexT 组织是由众多喜爱 NexT 主题及风格的世界各地友人共同组建而成，为的就是让这个主题继续在 Hugo 引擎中也能得到发扬光大，在此也欢迎你的加入！
我们的愿景 延续 NexT 经典的黑白调搭配，保持简单的易用性及强大的功能。
使用反馈 加入 GitHub Discussions 或 Gitter 在线讨论 &amp;#x1f37b; GitHub Issues 提交错误报告 &amp;#x1f41b; GitHub Feature 表新功能的想法 &amp;#x2728; 同时国内用户也可加入 QQ 群交流： 604710815
  </content></entry><entry><title>站点示例</title><url>/flinks.html</url><categories/><tags/><content type="html">  如想交换本站友情链接，请在评论区留下你的站点信息，格式参考如下：
- name: Hugo-NexT desc: Hugo NexT 官方预览网站。 avatar: https://hugo-next.eu.org/imgs/hugo_next_avatar.png link: https://hugo-next.eu.org   </content></entry></search>