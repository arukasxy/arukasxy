<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>queue队列</title><url>/post/queue-queue-z1b93g7.html</url><categories><category>数据结构</category></categories><tags><tag>队列</tag></tags><content type="html"><![CDATA[  queue队列 queue队列 底层实现 支持empty，size，front，back，push_back，pop_front 的容器
底层容器：deque（默认）、list
成员函数 函数 功能 front() 头部元素 back() 尾部元素 push() 尾部插入 pop() 删除头部 priority_queue优先级队列 #include &lt;queue&gt; # 最小堆，队头为最小值 priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; pq; pq.emplace(elem); pq.push(elem); pq.pop(); 底层实现 支持empty, size, front, push_back, pop_back 的容器
底层容器：vector（默认，结合堆算法）、deque
环形队列 rear指定队尾元素的后一位置
判断是否为空：front == rear
判断是否为满：front == (rear+1)%capacity
元素个数：
用数组C[1..m]表示的环形队列，m为数组的长度。假设f为队头元素在数组中的位置，r为队尾元素的后一位置（按顺时针方向）。若队列非空，则计算队列中元素个数的公式应为？$( m+r-f ) % m$
class MyCircularQueue { private: int front; int rear; int capacity; vector&lt;int&gt; elements; public: MyCircularQueue(int k) { this-&gt;capacity = k + 1; this-&gt;elements = vector&lt;int&gt;(capacity); rear = front = 0; } bool enQueue(int value) { // 增加一个元素，在堆尾rear插入 if (isFull()) { return false; } elements[rear] = value; rear = (rear + 1) % capacity; return true; } bool deQueue() { // 删除一个元素，在堆首front插入 if (isEmpty()) { return false; } front = (front + 1) % capacity; //循环队列 index+1如何处理 return true; } int Front() { if (isEmpty()) { return -1; } return elements[front]; } int Rear() { if (isEmpty()) { return -1; } return elements[(rear - 1 + capacity) % capacity]; //循环队列 index-1如何处理 } bool isEmpty() { return rear == front; } bool isFull() { return ((rear + 1) % capacity) == front; } }; deque双端队列 特点：支持任意位置的元素插入和删除；支持随机访问 实现：分段连续空间 #include &lt;deque&gt; deque&lt;string&gt; deq; 成员函数 函数 功能 push_back() 尾部插入 push_front() 头部插入 insert() 插入 pop_back() 尾部删除 pop_front() 头部删除 deq[1] 随机访问   ]]></content></entry><entry><title>元组</title><url>/post/turtle-1geggg.html</url><categories><category>数据结构</category></categories><tags><tag>tuple</tag><tag>pair</tag></tags><content type="html"><![CDATA[  元组 STL通常没有实现对应的哈希函数，因此在使用unordered_map/unordered_set时不能直接使用 pair对值 #include &lt;utility&gt; std::pair&lt;int, char&gt; mypair(std::make_pair(20, &#39;b&#39;)); mypair.first; mypair.second; # 接收pair对象 std::tie(name, ages) = func(); auto [a,b] = make_pair(2, 3); tuple元组 #include &lt;tuple&gt; std::tuple&lt;int, char&gt; mytuple(std::make_tuple(20, &#39;b&#39;)) # 接收tuple对象 std::get&lt;0&gt;(mytuple) = 100; auto [a, b, c] = mytuple; std::tie(a, b, c) = std::make_tuple(&#34;Tom&#34;, 20, 1.75); 展开为函数参数 可变参数模板参考可变参数，需C++17支持
# 配合函数使用 int sum(int a, int b, int c) { return a + b + c; } std::tuple&lt;int,int,int&gt; t(1,2,3); # sum为可调用对象 int res = std::apply(sum, std::move(t)); # 配合可变参数模板使用，注意使用lambda封装，使用auto自动类型推导 #include &lt;iostream&gt; #include &lt;tuple&gt; #include &lt;utility&gt; using namespace std; template&lt;typename T&gt; T sum(T t) { return t; } template&lt;typename T, typename... Types&gt; T sum(T first, Types... rest) { return first + sum&lt;T&gt;(rest...); } int main(){ std::tuple&lt;int,int,int&gt; t(1, 2, 3); cout&lt;&lt; std::apply([](auto &amp;&amp;... args) {return sum(args...);},std::move(t))&lt;&lt;endl; return 0; } # 配合仿函数使用 struct TT { int sum(int a, int b, int c) { return a + b + c; } }; int main(int argc, const char *argv[]) { std::tuple tu(TT(), 1, 2, 3); // 第一个成员就是调用成员 int res = std::apply(&amp;TT::sum, std::move(tu)); // 这里传成员函数指针 // 等同于std::get&lt;0&gt;(tu).sum(1, 2, 3) std::cout &lt;&lt; res &lt;&lt; std::endl; return 0; } # 配合匿名函数使用 std::tuple&lt;int, std::string, float&gt; t1(10, &#34;Test&#34;, 3.14); std::apply([](auto&amp;&amp;... args) { ((std::cout &lt;&lt; args &lt;&lt; &#39;\n&#39;), ...); }, t1); 展开为构造函数参数 class Test { public: Test(int a, double b, const std::string &amp;c): a_(a), b_(b), c_(c) {} void show() const {std::cout &lt;&lt; a_ &lt;&lt; &#34; &#34; &lt;&lt; b_ &lt;&lt; &#34; &#34; &lt;&lt; c_ &lt;&lt; std::endl;} private: int a_; double b_; std::string c_; }; // 自行封装构造过程 template &lt;typename T, typename... Args&gt; T Create(Args &amp;&amp;...args) { return T(args...); } int main(int argc, const char *argv[]) { std::tuple tu(1, 2.5, &#34;abc&#34;); # 1. 使用make_form_tuple Test &amp;&amp;t = std::make_from_tuple&lt;Test&gt;(std::move(tu)); # 2. 使用自己的封装结构 Create Test &amp;&amp;t = std::apply([](auto &amp;&amp;...args)-&gt;Test {return Create&lt;Test&gt;(args...);}, std::move(tu)); t.show(); // 打印：1 2.5 abc return 0; }   ]]></content></entry><entry><title>哈希表</title><url>/post/hash-table-z26kjag.html</url><categories><category>数据结构</category></categories><tags><tag>哈希表</tag></tags><content type="html"><![CDATA[  哈希表 装填因子 定义：元素个数/表长
最大装填因子一般取 0.5 &lt;= α&lt;= 0.85
平均查找长度 查找成功时的平均查找长度 = 表中每个元素查找成功时的比较次数之和 / 表中元素个数
哈希函数 标准：
函数本身便于计算 算出来的地址分布均匀，即对任一关键字k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突 常见方法：
直接定址法 除留余数法 乘余取整法 数字分析法 平方取中法 折叠法 随机数法 哈希冲突算法 算法 思想 开放定址
再散列法
闭哈希表 按某种规则找到哈希表中空闲的位置
$hi(key) = (h(key)+di)% TableSize$
1. 线性探测再散列法（从冲突的位置开始，依次判断下一个位置是否空闲）
2. 平方探查法（从冲突的位置x开始，第一次增加12个位置，第二次增加22&hellip;，直至找到空闲的位置）
3. 双散列函数探查法（di = i * h2(key)）
4. 伪随机探查法（建立一个伪随机数发生器，生成一个伪随机序列，并给定一个随机数做起点，每次加上伪随机数） 链地址法
闭式寻址
开哈希表
哈希地址相同的元素构成链表或红黑树 公共溢出区 将数据存储到公共溢出区 再哈希法 使用新的哈希函数计算哈希值 可拓展哈希 溢出后全局标志位+1，根据前n位区分，拓展后rehash 线性哈希 对0号槽拆分，建立4号槽，0号槽使用新的哈希函数，0号槽数据分配的0和4号槽中 Cuckoo哈希 使用2个hash函数来处理碰撞，从而每个key都对应到2个位置（如果均冲突，任选一个位置，把key值插入，把已经在那个位置的key值踢出来重新插入） Robin Hood哈希 &ldquo;劫富济贫（偏移量越小越富裕，如果遇到一个已经被占用的slot且它比自己富裕, 就代替它的位置, 然后把它顺延到新的位置。）&rdquo;, 记录每个元素离自己原本位置的偏移量 线性探测法 n个关键字中已知有k个关键字哈希值相同，若用线性探测法将它们存入散列表，至少需要进行$k(k-1)/2$次探测。
‍
  ]]></content></entry><entry><title>map字典</title><url>/post/map-dictionary-z1xnnbh.html</url><categories><category>数据结构</category></categories><tags><tag>字典</tag></tags><content type="html"><![CDATA[  map字典 成员函数 函数 功能 empty() 判空 map 底层实现：红黑树，查找时间复杂度为$O(logn)$ 按key进行排序，默认std::less从小到大 key可以使用pair #include &lt;map&gt; # 从大到小排序 map&lt;string, int, std::greater&lt;string&gt;&gt; mapWord; # 删除数据 mp.erase(key) if(iter != mp.end()) iter = mp.erase (iter) ; unordered_map 底层实现：哈希表 查询复杂度为O(1)，适用于查找频率高 key不能使用pair，需自定义哈希函数 不能删除指定元素 #include &lt;unordered_map&gt; unordered_map&lt;int, string&gt; mp = {{1, &#34;apple&#34;}, {2,&#34;watermelon&#34;}}; # 添加数据 mp.insert(unordered_map&lt;int,string&gt;::value_type(1,”sakura”)) mp.insert(std::pair&lt;int,string&gt;(1,”sakura”)) mp.insert(std::make_pair(1,”sakura”)) people[&#34;Jim&#34;] = 22; # 删除元素 mp.erase(key) //返回删除元素的个数 if(iter != mp.end()) iter = mp.erase (iter) ;	//返回被移除元素后的元素的迭代器 multimap 底层实现：红黑树，查找时间复杂度为$O(logn)$
允许key重复
#include &lt;multimap&gt; ‍
  ]]></content></entry><entry><title>stack栈</title><url>/post/stack-stack-zfgeku.html</url><categories><category>数据结构</category></categories><tags><tag>栈</tag></tags><content type="html"><![CDATA[  stack栈 栈 特点：
先入后出 #include &lt;stack&gt; stack&lt;int&gt; st; 底层实现 支持empty()、back()、push_back()、pop_back()的容器
底层容器：vector、deque（默认）、list
成员函数 函数 功能 push() 压栈 pop() 弹栈 top() 栈顶 stack().swap(st) 清空 出栈序列 n个不同元素进栈，出栈序列的个数为$1/(n+1)*\mathrm{C}_{2n}^{n}$ 双栈 ​​
特点：
用一个数组存储两个栈 场景：
当两个栈的空间需求有相反的关系时；
最好是一个栈增长时，另一个栈缩短；
需要从一个栈中取出元素放入另一个栈   ]]></content></entry><entry><title>树</title><url>/post/tree-zytrkb.html</url><categories><category>数据结构</category></categories><tags><tag>树</tag></tags><content type="html">  树 树 结点总数 = Σ（度数*该度数对应的结点数）+1 = 度不为0的节点数 + 叶子节点数
二叉树 哈夫曼树（最优二叉树） 原理：贪心算法。每次选k个权重最小的元素来合成一个新的元素，该元素权重为k个元素权重之和。
权值较大的节点离跟结点较近
在哈夫曼树中没有度为1的结点，只有度为0（叶子结点）和度为2的结点
度为m指节点的度为0或m，则边数 = 点数-1 = 度数之和​
若度为m的哈夫曼树中，其叶结点个数为n，则非叶结点​的个数为（x）
x*m=x+n-1
Huffman树的结构不是唯一的，但带权路径和是唯一的。
构建 权值w={19、6、7、3、32、10、21、2 }
从小到大排序 选择最小的两个叶子结点，分别为2和3，计算两个结点的和作为根 找当前树的根结点和剩余叶子结点的最小的两个值，然后组成新的树杈（两者的和作为根） ​​
带权路径长度WPL ∑层数*该层叶子结点权值和
WPL = 2 * (32 + 19 + 21) + 4 * (6 + 7 + 10) + 5 * (3 + 2) = 261
除根节点以外的所有数字的和
WPL = 60 + 40 + 28 + 32 + 19 + 21 + 11 + 17 + 5 + 6 + 7 + 10 + 3 + 2 = 261
K叉树（最佳归并树） 对于 k 叉树，设 m 为叶子数 , 若 ( m-1 ) % ( k-1 ) != 0 , 要增加虚(子叶)结点。虚节点数量需要使等式成立。 已知三叉树T中6个叶结点的权分别是2，3，4，5，6，7，T的带权路径长度最小是（46） 设外存上有120个初始归并段，进行12路归并时，为实现最佳归并，需要补充的虚段个数是（2）   </content></entry><entry><title>链表</title><url>/post/linked-z1xhzbs.html</url><categories><category>数据结构</category></categories><tags><tag>链表</tag></tags><content type="html"><![CDATA[  链表 单向链表 #include &lt;forward_list&gt; push_front() // 无push_back() emplace_front() front() // 无back() int size = std::distance(std::begin(v), std::end(v)); 成员函数 不支持size()
函数 功能 before_begin() 返回指向第一个元素之前位置的迭代器 push_front() 头部插入 pop_front() 头部删除 insert_after() 插入元素 erase_after() 删除指定元素 双向链表 #include &lt;list&gt; # 创建一个有十个元素的list对象，每个元素都为4 list&lt;int&gt; l(10,4); 成员函数 函数 功能 push_back 尾部插入 push_front 头部插入 pop_back 尾部删除 pop_front 头部删除 剪切splice # 将it指向的元素剪切到x的position上去，不会导致迭代器it失效 void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x, iterator it );   ]]></content></entry><entry><title>数字</title><url>/post/number-z2upfwa.html</url><categories><category>数据结构</category></categories><tags><tag>数字</tag></tags><content type="html"><![CDATA[  数字 大小范围（数值极限） 数据类型 大小 头文件 INT_MAX
INT_MIN 2147483647(10位)
-2147483648
limits.h FLT_MAX
FLT_MIN limits.h DBL_MAX
DBL_MIN float.h LONG_MAX
LONG_MIN
LLONG_MAX
LLONG_MIN
float能表示的最大正整数为2^32
double能表示的最大正整数为2^64
#include &lt;limits&gt; using PageNum = int32_t; std::numeric_limits&lt;PageNum&gt;::max() std::numeric_limits&lt;short&gt;::max() numeric_limits&lt;char&gt;::is_signed // 是否带符号 numeric_limits&lt;string&gt;::is_specialized // 是否存在limit 空间大小(+数字类型) 数字类型 32位 64位 char 1字节 short 2 int 4 float 4 double 8 long 4 8 long long 8 unsigned long long 8 进制转换 也可以使用stringstream实现
# 任意进制转十进制 int a = stoi(str, 0, 2); int stoi(int m, string s){ int ans=0; for(int i=0;i&lt;s.size();i++){ char t=s[i]; if(t&gt;=&#39;0&#39;&amp;&amp;t&lt;=&#39;9&#39;) ans=ans*m+t-&#39;0&#39;; else ans=ans*m+t-&#39;a&#39;+10; } return ans; } # 十进制数n转任意m进制 #include&lt;cstdlib&gt; char *itoa(int value, char *string, int radix); itoa(num, str, 2); string itoa(int n,int m){ string ans=&#34;&#34;; do{ int t=n%m; if(t&gt;=0&amp;&amp;t&lt;=9) ans+=(t+&#39;0&#39;); else ans+=(t+&#39;a&#39;-10); n/=m; }while(n); reverse(ans.begin(),ans.end()); return ans; } 随机数生成rand 要取得[a,b)的随机整数，使用(rand() % (b-a))+ a （结果值含a不含b）
要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a （结果值含a和b）
要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1 （结果值不含a含b）
#include&lt;time.h&gt; #include&lt;cstdlib&gt; # 设置随机种子，time(nullptr) 一秒钟才变化一次，作为随机种子变化频率太低，容易被预测 srand(time(NULL)); # 生成[0,i)之间的随机数 #define random(x) (rand()%x) # 使用静态变量保存状态，调用时加锁，不可重入 int rand(void); # rand的可重入版本 int rand_r(unsigned int *seedp); 判断两个数是否异号 int x = -1, y = 2; bool f = ((x ^ y) &lt; 0); // true 判断是否是2的指数 原理：一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1
bool isPowerOfTwo(int n) { if (n &lt;= 0) return false; return (n &amp; (n - 1)) == 0; } 数字类型大小size_t #include &lt;cstddef&gt; ‍
  ]]></content></entry><entry><title>关于 Hugo NexT 组织</title><url>/about.html</url><categories/><tags/><content type="html">  Hugo NexT 组织是由众多喜爱 NexT 主题及风格的世界各地友人共同组建而成，为的就是让这个主题继续在 Hugo 引擎中也能得到发扬光大，在此也欢迎你的加入！
我们的愿景 延续 NexT 经典的黑白调搭配，保持简单的易用性及强大的功能。
使用反馈 加入 GitHub Discussions 或 Gitter 在线讨论 &amp;#x1f37b; GitHub Issues 提交错误报告 &amp;#x1f41b; GitHub Feature 表新功能的想法 &amp;#x2728; 同时国内用户也可加入 QQ 群交流： 604710815
  </content></entry><entry><title>站点示例</title><url>/flinks.html</url><categories/><tags/><content type="html">  如想交换本站友情链接，请在评论区留下你的站点信息，格式参考如下：
- name: Hugo-NexT desc: Hugo NexT 官方预览网站。 avatar: https://hugo-next.eu.org/imgs/hugo_next_avatar.png link: https://hugo-next.eu.org   </content></entry></search>